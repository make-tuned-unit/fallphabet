<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>FALLPHABET</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js?v=1"></script>
  <style>
    html {
      background: #ffe5d9;
    }
    body {
      background: #ffe5d9;
      min-height: 100vh;
      min-width: 100vw;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      background: transparent;
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  <div id="main-content">
    <!-- Header Section -->
    <header class="game-header">
      <h1 class="game-title">FALLPHABET</h1>
      <div class="game-stats">
        <div class="stat-item">
          <span class="stat-label">Points:</span>
          <span id="score-display" class="stat-value">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label chain-label" title="Chain Multiplier">
            <svg class="chain-svg" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" width="22" height="22" style="vertical-align:middle;margin-right:4px;"><rect x="12.7835" y="2.38351" width="6" height="10" rx="3" transform="rotate(33.0385 12.7835 2.38351)" stroke="#000000" stroke-width="2" stroke-linecap="round"></rect> <rect x="7.83558" y="6.32284" width="6" height="10" rx="3" transform="rotate(33.0385 7.83558 6.32284)" stroke="#000000" stroke-width="2" stroke-linecap="round"></rect></svg>
          </span>
          <span id="chain-display" class="stat-value">x1</span>
        </div>
      </div>
    </header>

    <!-- Playfield Container (only one, centered) -->
    <div id="playfield-container"></div>
  </div>

  <!-- Flash Message Area -->
  <div id="flash-message" class="flash-message"></div>
  
  <script>
    // TileSpawner Module
    class TileSpawner {
      constructor(scene, gridX, gridY, gridWidth, gridHeight, columns, rows) {
        this.scene = scene;
        this.gridX = gridX;
        this.gridY = gridY;
        this.gridWidth = gridWidth;
        this.gridHeight = gridHeight;
        this.columns = columns;
        this.rows = rows;
        this.tileSize = (this.gridWidth / this.columns) * 0.8; // Scrabble tile size with margin
        this.tileMargin = (this.gridWidth / this.columns - this.tileSize) / 2;
        this.tileSpacing = 10; // vertical gap between tiles (increased to 10px)
        this.fallSpeed = 90; // pixels/sec
        this.letters = {
          'E': 12, 'A': 9, 'I': 9, 'N': 6, 'O': 8, 'R': 6, 'T': 6, 'L': 4, 'S': 4, 'U': 4,
          'D': 4, 'P': 2, 'M': 2, 'H': 2, 'G': 3, 'B': 2, 'F': 2, 'Y': 2, 'W': 2, 'K': 1,
          'V': 2, 'X': 1, 'Z': 1, 'J': 1, 'Q': 1
        };
        this.letterPool = [];
        this.buildLetterPool();
        // Each column has a queue of falling tiles
        this.columnsTiles = Array.from({length: columns}, () => []);
        this.columnX = [];
        for (let i = 0; i < columns; i++) {
          this.columnX.push(gridX + (i + 0.5) * (gridWidth / columns));
        }
        // Set up per-column spawn timers for natural cascade
        this.columnTimers = [];
        for (let col = 0; col < this.columns; col++) {
          const spawnNext = () => {
            // Only spawn if last tile is far enough down
            const colTiles = this.columnsTiles[col];
            const lastTile = colTiles.length > 0 ? colTiles[colTiles.length - 1] : null;
            const spawnY = this.gridY - this.tileSize / 2;
            if (lastTile && lastTile.y < spawnY + this.tileSize + this.tileSpacing) {
              // Not enough space, retry soon
              this.columnTimers[col] = this.scene.time.addEvent({
                delay: 100,
                callback: spawnNext,
                callbackScope: this
              });
              return;
            }
            const tile = this.spawnTile(col, spawnY);
            this.columnsTiles[col].push(tile);
            // Schedule the next spawn with a new random delay
            this.columnTimers[col] = this.scene.time.addEvent({
              delay: Phaser.Math.Between(900, 1200),
              callback: spawnNext,
              callbackScope: this
            });
          };
          // Start the first spawn with a random initial delay per column
          this.scene.time.addEvent({
            delay: Phaser.Math.Between(0, 800),
            callback: spawnNext,
            callbackScope: this
          });
        }
      }
      
      buildLetterPool() {
        for (const [letter, freq] of Object.entries(this.letters)) {
          for (let i = 0; i < freq; i++) this.letterPool.push(letter);
        }
      }
      
      getRandomLetter() {
        return this.letterPool[Math.floor(Math.random() * this.letterPool.length)];
      }
      
      spawnTile(col, y) {
        const letter = this.getRandomLetter();
        const x = this.columnX[col];
        // Shadow (subtle, larger, more transparent)
        const shadow = this.scene.add.rectangle(x + 3, y + 6, this.tileSize + 4, this.tileSize + 4, 0xC2A477, 0.18);
        shadow.setDepth(0);
        // Main tile (rounded rectangle)
        const tile = this.scene.add.rectangle(x, y, this.tileSize, this.tileSize, 0xFFF5E1);
        tile.setStrokeStyle(3, 0xB8860B);
        tile.setDepth(1);
        tile.setInteractive();
        tile.isScrabbleTile = true;
        tile.radius = 12;
        // Inner shadow (drawn as a slightly smaller, semi-transparent rectangle)
        const innerShadow = this.scene.add.rectangle(x, y, this.tileSize - 6, this.tileSize - 6, 0x8B6B2F, 0.08);
        innerShadow.setDepth(2);
        // Letter text
        const text = this.scene.add.text(x, y, letter, {
          fontFamily: 'Roboto Slab', fontSize: '32px', color: '#222', fontStyle: 'bold',
        }).setOrigin(0.5);
        text.setDepth(3);
        text.setShadow(2, 3, '#B8860B', 2, false, true);
        // Apply the grid mask to all tile elements
        const mask = this.scene.gridMask;
        tile.setMask(mask);
        text.setMask(mask);
        shadow.setMask(mask);
        innerShadow.setMask(mask);
        tile.letter = letter;
        tile.text = text;
        tile.col = col;
        tile.falling = true;
        tile.shadow = shadow;
        tile.innerShadow = innerShadow;
        // Add a subtle spawn animation
        tile.setScale(0.85);
        text.setScale(0.85);
        shadow.setScale(0.85);
        innerShadow.setScale(0.85);
        this.scene.tweens.add({
          targets: [tile, text, shadow, innerShadow],
          scaleX: 1,
          scaleY: 1,
          duration: 300,
          ease: 'Back.easeOut'
        });
        return tile;
      }
      
      update(dt) {
        for (let col = 0; col < this.columns; col++) {
          let colTiles = this.columnsTiles[col];
          for (let i = 0; i < colTiles.length; i++) {
            const tile = colTiles[i];
            if (!tile.falling) continue;
            tile.y += 50 * dt;
            tile.text.y = tile.y;
            if (tile.shadow) tile.shadow.y = tile.y + 6;
            if (tile.innerShadow) tile.innerShadow.y = tile.y;
          }
          // Remove tiles with smooth slide-out animation
          for (let i = colTiles.length - 1; i >= 0; i--) {
            const tile = colTiles[i];
            if (tile.y + this.tileSize / 2 >= this.scene.playfieldBottomY) {
              this.scene.tweens.add({
                targets: [tile, tile.text, tile.shadow, tile.innerShadow],
                scaleX: 0.8,
                scaleY: 0.8,
                alpha: 0,
                duration: 200,
                ease: 'Power2',
                onComplete: () => {
                  tile.destroy();
                  tile.text.destroy();
                  if (tile.shadow) tile.shadow.destroy();
                  if (tile.innerShadow) tile.innerShadow.destroy();
                }
              });
              colTiles.splice(i, 1);
            }
          }
        }
      }
      
      getAllTiles() {
        return this.columnsTiles.flat();
      }
    }

    // InputHandler Module
    class InputHandler {
      constructor(scene, tileSpawner) {
        this.scene = scene;
        this.tileSpawner = tileSpawner;
        this.selectedTiles = [];
        this.buffer = [];
        this.isDragging = false;
        this.lastTile = null;
        
        // Set up input events
        this.scene.input.on('pointerdown', this.onPointerDown, this);
        this.scene.input.on('pointermove', this.onPointerMove, this);
        this.scene.input.on('pointerup', this.onPointerUp, this);
      }
      
      onPointerDown(pointer) {
        this.isDragging = true;
        this.clearBuffer();
        this.selectTileAt(pointer.x, pointer.y);
      }
      
      onPointerMove(pointer) {
        if (!this.isDragging) return;
        this.selectTileAt(pointer.x, pointer.y);
      }
      
      onPointerUp(pointer) {
        if (this.isDragging && this.buffer.length > 0) {
          this.submitWord();
        }
        this.isDragging = false;
        this.clearBuffer();
      }
      
      selectTileAt(x, y) {
        const tiles = this.tileSpawner.getAllTiles();
        for (const tile of tiles) {
          if (!tile || tile.destroyed || !tile.isScrabbleTile) continue;
          
          const distance = Phaser.Math.Distance.Between(x, y, tile.x, tile.y);
          if (distance <= tile.width / 2) {
            if (this.lastTile && tile !== this.lastTile) {
              // Check if this tile is adjacent to the last selected tile
              const lastCol = this.lastTile.col;
              const currentCol = tile.col;
              const lastIndex = this.tileSpawner.columnsTiles[lastCol].indexOf(this.lastTile);
              const currentIndex = this.tileSpawner.columnsTiles[currentCol].indexOf(tile);
              
              const isAdjacent = (
                (Math.abs(currentCol - lastCol) === 1 && Math.abs(currentIndex - lastIndex) <= 1) ||
                (currentCol === lastCol && Math.abs(currentIndex - lastIndex) === 1)
              );
              
              if (!isAdjacent) continue;
            }
            
            if (!this.selectedTiles.includes(tile)) {
              this.selectedTiles.push(tile);
              this.buffer.push(tile.letter);
              this.highlightTile(tile, true);
            }
            
            this.lastTile = tile;
            break;
          }
        }
      }
      
      highlightTile(tile, highlight) {
        if (!tile || tile.destroyed) return;
        
        if (highlight) {
          tile.setFillStyle(0x90EE90); // Light green
          tile.setStrokeStyle(3, 0x228B22); // Dark green border
          if (tile.text) tile.text.setColor('#006400');
        } else {
          tile.setFillStyle(0xFFF5E1); // Original color
          tile.setStrokeStyle(3, 0xB8860B); // Original border
          if (tile.text) tile.text.setColor('#222');
        }
      }
      
      clearBuffer() {
        this.selectedTiles.forEach(tile => this.highlightTile(tile, false));
        this.selectedTiles = [];
        this.buffer = [];
        this.lastTile = null;
      }
      
      submitWord() {
        if (this.buffer.length < 2) return;
        
        const word = this.buffer.join('');
        this.scene.events.emit('wordSubmitted', {
          word: word,
          tiles: [...this.selectedTiles]
        });
      }
      
      update() {
        // Any per-frame updates if needed
      }
    }

    // WordValidator Module
    class WordValidator {
      constructor() {
        this.dictionary = new Set();
        this.loadDictionary();
      }
      
      async loadDictionary() {
        try {
          const response = await fetch('https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt');
          const text = await response.text();
          const words = text.split('\n').map(word => word.trim().toUpperCase());
          words.forEach(word => {
            if (word.length >= 2) {
              this.dictionary.add(word);
            }
          });
          console.log(`Loaded ${this.dictionary.size} words`);
        } catch (error) {
          console.error('Error loading dictionary:', error);
          // Fallback to a small set of common words
          const fallbackWords = ['HELLO', 'WORLD', 'GAME', 'PLAY', 'FUN', 'WORD', 'LETTER', 'TILE'];
          fallbackWords.forEach(word => this.dictionary.add(word));
        }
      }
      
      async validate(word) {
        if (word.length < 2) return false;
        return this.dictionary.has(word.toUpperCase());
      }
    }

    // ScoreManager Module
    class ScoreManager {
      constructor() {
        this.totalScore = 0;
        this.letterScores = {
          'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1, 'F': 4, 'G': 2, 'H': 4, 'I': 1, 'J': 8,
          'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1, 'P': 3, 'Q': 10, 'R': 1, 'S': 1, 'T': 1,
          'U': 1, 'V': 4, 'W': 4, 'X': 8, 'Y': 4, 'Z': 10
        };
      }
      
      calculateScore(word, chainMultiplier = 1) {
        let score = 0;
        for (const letter of word.toUpperCase()) {
          score += this.letterScores[letter] || 0;
        }
        return score * chainMultiplier;
      }
      
      addScore(points) {
        this.totalScore += points;
      }
      
      getTotalScore() {
        return this.totalScore;
      }
    }

    // ChainTracker Module
    class ChainTracker {
      constructor() {
        this.chainLevel = 1;
        this.chainTimer = 0;
        this.chainDuration = 5000; // 5 seconds
        this.awaitingNextWord = false;
      }
      
      increaseChain() {
        this.chainLevel++;
        this.chainTimer = this.chainDuration;
        this.awaitingNextWord = false;
      }
      
      update() {
        if (this.chainTimer > 0) {
          this.chainTimer -= 16; // Assuming 60fps
          if (this.chainTimer <= 0) {
            this.resetChain();
          }
        }
      }
      
      resetChain() {
        this.chainLevel = 1;
        this.chainTimer = 0;
        this.awaitingNextWord = false;
      }
      
      getChainLevel() {
        return this.chainLevel;
      }
    }

    // GameScene
    class GameScene extends Phaser.Scene {
      constructor() {
        super({ key: 'GameScene' });
        this.columns = 4;
        this.rows = 12;
      }
      
      create() {
        console.log('Creating GameScene...');
        
        // Calculate playfield dimensions
        const playfieldWidth = 480;
        const playfieldHeight = 900;
        this.gridX = 50;
        this.gridY = 50;
        this.gridWidth = playfieldWidth - 100;
        this.gridHeight = playfieldHeight - 100;
        this.playfieldBottomY = this.gridY + this.gridHeight;
        
        // Create grid outline
        this.grid = this.add.rectangle(
          this.gridX + this.gridWidth / 2,
          this.gridY + this.gridHeight / 2,
          this.gridWidth,
          this.gridHeight,
          0xFFFFFF,
          0
        );
        this.grid.setStrokeStyle(3, 0x000000);
        
        // Create a geometry mask for the playfield
        const maskShape = this.add.graphics();
        maskShape.fillStyle(0xffffff);
        maskShape.fillRect(this.gridX, this.gridY, this.gridWidth, this.gridHeight);
        this.gridMask = maskShape.createGeometryMask();
        
        // Add column dividers for better visual separation
        for (let i = 1; i < this.columns; i++) {
          const dividerX = this.gridX + (i * this.gridWidth / this.columns);
          this.add.line(dividerX, this.gridY, dividerX, this.gridY + this.gridHeight, 0x8B4513, 2);
        }
        
        // Initialize modules
        console.log('Initializing modules...');
        this.tileSpawner = new TileSpawner(this, this.gridX, this.gridY, this.gridWidth, this.gridHeight, this.columns, this.rows);
        
        this.inputHandler = new InputHandler(this, this.tileSpawner);
        this.wordValidator = new WordValidator();
        this.scoreManager = new ScoreManager();
        this.chainTracker = new ChainTracker();
        
        // Game state
        this.wordsUsed = 0;
        
        // Listen for word submissions
        this.events.on('wordSubmitted', this.handleWordSubmission, this);
        
        console.log('GameScene create completed');

        // Add bottom border line
        this.add.line(
          this.gridX,
          this.gridY + this.gridHeight,
          this.gridX + this.gridWidth,
          this.gridY + this.gridHeight,
          0x000000,
          1
        ).setOrigin(0, 0).setLineWidth(3).setDepth(100);
      }

      update(time, delta) {
        const dt = delta / 1000;
        this.tileSpawner.update(dt);
        this.chainTracker.update();
        this.inputHandler.update();
        this.updateUI();
      }
      
      async handleWordSubmission(data) {
        const { word, tiles } = data;
        if (this.inputHandler) this.inputHandler.clearBuffer();
        
        // Always clean up tiles from spawner tracking, regardless of validation result
        tiles.forEach(tile => {
          if (tile && tile.col !== undefined && this.tileSpawner.columnsTiles[tile.col]) {
            const colIndex = this.tileSpawner.columnsTiles[tile.col].indexOf(tile);
            if (colIndex > -1) {
              this.tileSpawner.columnsTiles[tile.col].splice(colIndex, 1);
            }
          }
        });
        
        const isValid = await this.wordValidator.validate(word);
        if (!isValid) {
          this.showFlashMessage(`"${word}" - Invalid word!`, '#ff6b6b');
          if (this.chainTracker) this.chainTracker.awaitingNextWord = false;
          tiles.forEach(tile => {
            // Remove from column tracking
            if (tile && tile.col !== undefined && this.tileSpawner.columnsTiles[tile.col]) {
              const colIndex = this.tileSpawner.columnsTiles[tile.col].indexOf(tile);
              if (colIndex > -1) {
                this.tileSpawner.columnsTiles[tile.col].splice(colIndex, 1);
              }
            }
            // Animate and destroy
            this.tweens.add({
              targets: [tile, tile.text, tile.shadow, tile.innerShadow],
              scaleX: 0,
              scaleY: 0,
              alpha: 0,
              duration: 200,
              ease: 'Power2',
              onComplete: () => {
                if (tile && !tile.destroyed) tile.destroy();
                if (tile.text && !tile.text.destroyed) tile.text.destroy();
                if (tile.shadow && !tile.shadow.destroyed) tile.shadow.destroy();
                if (tile.innerShadow && !tile.innerShadow.destroyed) tile.innerShadow.destroy();
              }
            });
            setTimeout(() => {
              if (tile && !tile.destroyed) tile.destroy();
              if (tile.text && !tile.text.destroyed) tile.text.destroy();
              if (tile.shadow && !tile.shadow.destroyed) tile.shadow.destroy();
              if (tile.innerShadow && !tile.innerShadow.destroyed) tile.innerShadow.destroy();
            }, 400);
          });
          return;
        }
        
        const chainLevel = this.chainTracker.getChainLevel();
        const score = this.scoreManager.calculateScore(word, chainLevel);
        this.scoreManager.addScore(score);
        this.wordsUsed++;
        this.chainTracker.increaseChain();
        this.showFlashMessage(`"${word}" - ${score} pts`, '#51cf66');
        
        // For valid words, animate and destroy tiles
        tiles.forEach(tile => {
          // Remove green border/highlight before destroying
          if (tile.setFillStyle) tile.setFillStyle(0xFFF5E1);
          if (tile.setStrokeStyle) tile.setStrokeStyle(3, 0xB8860B);
          if (tile.text && tile.text.setColor) tile.text.setColor('#222');
          this.tweens.add({ 
            targets: [tile, tile.text, tile.shadow, tile.innerShadow], 
            scaleX: 0, 
            scaleY: 0, 
            duration: 300, 
            ease: 'Power2', 
            onComplete: () => { 
              if (tile && !tile.destroyed) tile.destroy(); 
              if (tile.text && !tile.text.destroyed) tile.text.destroy(); 
              if (tile.shadow && !tile.shadow.destroyed) tile.shadow.destroy();
              if (tile.innerShadow && !tile.innerShadow.destroyed) tile.innerShadow.destroy();
            } 
          });
          setTimeout(() => {
            if (tile && !tile.destroyed) tile.destroy();
            if (tile.text && !tile.text.destroyed) tile.text.destroy();
            if (tile.shadow && !tile.shadow.destroyed) tile.shadow.destroy();
            if (tile.innerShadow && !tile.innerShadow.destroyed) tile.innerShadow.destroy();
          }, 400);
        });
      }
      
      showFlashMessage(message, color = '#fff') {
        const flashElement = document.getElementById('flash-message');
        flashElement.textContent = message;
        flashElement.style.color = color;
        flashElement.style.display = 'block';
        
        setTimeout(() => {
          flashElement.style.display = 'none';
        }, 2000);
      }
      
      updateUI() {
        // Update HTML elements instead of Phaser text
        document.getElementById('score-display').textContent = this.scoreManager.getTotalScore();
        document.getElementById('chain-display').textContent = `x${this.chainTracker.getChainLevel()}`;
      }
    }

    // Game Configuration
    const config = {
      type: Phaser.AUTO,
      width: 480,
      height: 900,
      backgroundColor: '#ffe5d9',
      parent: 'playfield-container',
      scene: [GameScene],
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 }, // Disable gravity, we'll control velocity manually
          debug: false,
        },
      },
    };

    // Start the game
    window.addEventListener('DOMContentLoaded', () => {
      console.log('DOM loaded, creating Phaser game...');
      try {
        const game = new Phaser.Game(config);
        console.log('Phaser game created successfully');
      } catch (error) {
        console.error('Error creating Phaser game:', error);
      }
    });
  </script>
</body>
</html>
