<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>FALLPHABET</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="style.css?v=56">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js?v=1"></script>
  <!-- Open Graph and Twitter Card for social sharing -->
  <meta property="og:title" content="Fallphabet" />
  <meta property="og:description" content="Try to win with as few words as possible!" />
  <meta property="og:image" content="/fallphabet-og.png" />
  <meta property="og:image:alt" content="FALLPHABET - Try to win with as few words as possible!" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://fallphabet.com" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Fallphabet" />
  <meta name="twitter:description" content="Try to win with as few words as possible!" />
  <meta name="twitter:image" content="/fallphabet-og.png" />
  <meta name="twitter:image:alt" content="FALLPHABET - Try to win with as few words as possible!" />
  <link rel="icon" type="image/png" href="/fallphabet-favicon.png">
  <style>
    html {
      background: #ffe5d9;
    }
    body {
      background: #ffe5d9;
      min-height: 100vh;
      min-width: 100vw;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      background: transparent;
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  <div id="main-content">
    <!-- Header Section -->
    <header class="game-header">
      <h1 class="game-title">FALLPHABET</h1>
      <div class="game-stats">
        <div class="stat-item">
          <span class="stat-label" style="font-family: 'Arial', 'Helvetica', sans-serif;">Points:</span>
          <span id="score-display" class="stat-value">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label chain-label" title="Chain Multiplier">
            <svg class="chain-svg" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" width="22" height="22" style="vertical-align:middle;margin-right:4px;"><rect x="12.7835" y="2.38351" width="6" height="10" rx="3" transform="rotate(33.0385 12.7835 2.38351)" stroke="#000000" stroke-width="2" stroke-linecap="round"></rect> <rect x="7.83558" y="6.32284" width="6" height="10" rx="3" transform="rotate(33.0385 7.83558 6.32284)" stroke="#000000" stroke-width="2" stroke-linecap="round"></rect></svg>
          </span>
          <span id="chain-display" class="stat-value">x1</span>
        </div>
        <!-- Taptile mode specific stats -->
        <div id="taptile-stats" class="taptile-stats" style="display: none;">
          <div class="stat-item">
            <span class="stat-label" style="font-family: 'Arial', 'Helvetica', sans-serif;">Speed:</span>
            <span id="speed-display" class="stat-value">1x</span>
          </div>
          <div class="stat-item">
            <span class="stat-label" style="font-family: 'Arial', 'Helvetica', sans-serif;">Time:</span>
            <span id="time-display" class="stat-value">5.0s</span>
          </div>
        </div>
      </div>
    </header>

    <!-- Top Menu Bar -->
    <div id="top-menu" class="top-menu">
      <!-- Mode Selector -->
      <div id="mode-selector" class="mode-selector">
        <button id="daily-mode-btn" class="mode-btn active" data-mode="daily">Daily</button>
        <button id="taptile-mode-btn" class="mode-btn" data-mode="taptile">Taptile</button>
      </div>
      
      <div class="menu-buttons">
        <button id="howto-btn" class="top-menu-btn" title="How to Play">?</button>
        <button id="stats-btn" class="top-menu-btn" title="Your Stats">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#7c3aed" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="12" width="4" height="8"/><rect x="9" y="8" width="4" height="12"/><rect x="15" y="4" width="4" height="16"/></svg>
        </button>
        <button id="leaderboard-btn" class="top-menu-btn" title="Global Leaderboard" style="display: none;">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#7c3aed" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M6 2v10"/><path d="M6 20h1.5a2.5 2.5 0 0 0 0-5H6"/><path d="M6 12v8"/><path d="M14 9h1.5a2.5 2.5 0 0 0 0-5H14"/><path d="M14 2v10"/><path d="M14 20h1.5a2.5 2.5 0 0 1 0-5H14"/><path d="M14 12v8"/><path d="M22 9h-1.5a2.5 2.5 0 0 1 0-5H22"/><path d="M22 2v10"/><path d="M22 20h-1.5a2.5 2.5 0 0 0 0-5H22"/><path d="M22 12v8"/></svg>
        </button>
      </div>
    </div>

    <!-- Playfield Container (only one, centered) -->
    <div id="playfield-container"></div>
  </div>

  <!-- Flash Message Area -->
  <div id="flash-message" class="flash-message"></div>

  <!-- Game Over Modal -->
  <div id="gameover-modal" class="slideup-modal">
    <div class="slideup-modal-content">
      <button id="modal-close-btn" class="slideup-close-btn" aria-label="Close">&times;</button>
      <h2 class="modal-title">Game Over!</h2>
      <div class="modal-stats">
        <div><strong>Words Used:</strong> <span id="modal-words-used">0</span></div>
        <div><strong>Top Word:</strong> <span id="modal-top-word">-</span></div>
        <div><strong>Highest Chain:</strong> <span id="modal-highest-chain">x1</span></div>
        <!-- Taptile mode specific stats -->
        <div id="taptile-modal-stats" style="display: none;">
          <div><strong>Final Score:</strong> <span id="modal-final-score">0</span></div>
          <div><strong>Max Speed:</strong> <span id="modal-max-speed">1x</span></div>
          <div><strong>Time Survived:</strong> <span id="modal-time-survived">0s</span></div>
        </div>
      </div>
      <div class="modal-actions">
        <button id="modal-share-btn" class="modal-btn">Share</button>
        <button id="modal-restart-btn" class="modal-btn">Try Again</button>
      </div>
    </div>
  </div>

  <!-- Slide-up How to Play Modal -->
  <div id="howto-modal" class="slideup-modal">
    <div class="slideup-modal-content">
      <button class="slideup-close-btn" id="howto-close">&times;</button>
      <h2>How to Play</h2>
      <div class="instructions-text">
        <h3>How to Play</h3>
        <p>• Tap tiles in sequence to build words</p>
        <p>• Double-tap last letter to submit</p>
        <p>• Tap outside grid to reset current word</p>
        <p>• Selection auto-clears after 1.25 seconds</p>
        
        <h3>Scoring & Chains</h3>
        <p>• Letters have point values (like Scrabble)</p>
        <p>• Longer words = more points</p>
        <p>• Start new word within 1.25 seconds to build chain</p>
        <p>• Chain multiplier: 2nd word x2, 3rd word x3, etc.</p>
        <p>• Miss timing = chain resets to x1</p>
        
        <h3 id="goal-title">Goal</h3>
        <div id="daily-goal">
          <p>• Reach 200 points with fewest words possible</p>
          <p>• No time limit - make words as long as possible</p>
        </div>
        <div id="taptile-goal" style="display: none;">
          <p>• Survive as long as possible with increasing speed</p>
          <p>• Make a new word within the time window or lose</p>
          <p>• Time window shrinks as speed increases</p>
          <p>• Go for the highest score on the global leaderboard!</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Slide-up Stats/History Modal -->
  <div id="stats-modal" class="slideup-modal">
    <div class="slideup-modal-content">
      <button class="slideup-close-btn" id="stats-close">&times;</button>
      <h2>Your Stats</h2>
      <div id="stats-history-content">
        <!-- Stats and history will be rendered here -->
      </div>
    </div>
  </div>

  <!-- Global Leaderboard Modal -->
  <div id="leaderboard-modal" class="slideup-modal">
    <div class="slideup-modal-content">
      <button class="slideup-close-btn" id="leaderboard-close">&times;</button>
      <h2>Global Leaderboard</h2>
      <div id="leaderboard-content">
        <div class="loading">Loading leaderboard...</div>
      </div>
    </div>
  </div>
  
  <script>
    // Game Mode Manager
    class GameModeManager {
      constructor() {
        this.currentMode = 'daily';
        this.modes = {
          daily: {
            name: 'Daily Challenge',
            goal: 200,
            timeLimit: null,
            speedIncrease: false,
            leaderboard: false
          },
          taptile: {
            name: 'Fallphabet Taptile',
            goal: null,
            timeLimit: 5.0,
            speedIncrease: true,
            leaderboard: true
          }
        };
      }
      
      setMode(mode) {
        this.currentMode = mode;
        this.updateUI();
      }
      
      getCurrentMode() {
        return this.modes[this.currentMode];
      }
      
      updateUI() {
        // Update mode buttons
        document.querySelectorAll('.mode-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector(`[data-mode="${this.currentMode}"]`).classList.add('active');
        
        // Update stats display
        const taptileStats = document.getElementById('taptile-stats');
        const leaderboardBtn = document.getElementById('leaderboard-btn');
        
        if (this.currentMode === 'taptile') {
          taptileStats.style.display = 'flex';
          leaderboardBtn.style.display = 'block';
        } else {
          taptileStats.style.display = 'none';
          leaderboardBtn.style.display = 'none';
        }
        
        // Update instructions
        const dailyGoal = document.getElementById('daily-goal');
        const taptileGoal = document.getElementById('taptile-goal');
        
        if (this.currentMode === 'taptile') {
          dailyGoal.style.display = 'none';
          taptileGoal.style.display = 'block';
        } else {
          dailyGoal.style.display = 'block';
          taptileGoal.style.display = 'none';
        }
      }
    }

    // Taptile Speed Manager
    class TaptileSpeedManager {
      constructor() {
        this.baseSpeed = 150;
        this.currentSpeed = this.baseSpeed;
        this.speedMultiplier = 1.0;
        this.timeWindow = 5.0;
        this.lastWordTime = 0;
        this.speedIncreaseInterval = 30; // Increase speed every 30 seconds
        this.speedIncreaseAmount = 0.2; // 20% increase
        this.timeWindowDecrease = 0.5; // 0.5 second decrease
        this.minTimeWindow = 1.0; // Minimum 1 second
        this.maxSpeedMultiplier = 5.0; // Maximum 5x speed
        this.speedTimer = null;
      }
      
      start() {
        this.currentSpeed = this.baseSpeed;
        this.speedMultiplier = 1.0;
        this.timeWindow = 5.0;
        this.lastWordTime = Date.now();
        this.startSpeedTimer();
        this.updateUI();
      }
      
      startSpeedTimer() {
        this.speedTimer = setInterval(() => {
          this.increaseSpeed();
        }, this.speedIncreaseInterval * 1000);
      }
      
      increaseSpeed() {
        this.speedMultiplier = Math.min(this.speedMultiplier + this.speedIncreaseAmount, this.maxSpeedMultiplier);
        this.currentSpeed = this.baseSpeed * this.speedMultiplier;
        this.timeWindow = Math.max(this.timeWindow - this.timeWindowDecrease, this.minTimeWindow);
        this.updateUI();
      }
      
      onWordSubmitted() {
        this.lastWordTime = Date.now();
      }
      
      checkTimeWindow() {
        const now = Date.now();
        const timeSinceLastWord = (now - this.lastWordTime) / 1000;
        return timeSinceLastWord <= this.timeWindow;
      }
      
      getCurrentSpeed() {
        return this.currentSpeed;
      }
      
      getSpeedMultiplier() {
        return this.speedMultiplier;
      }
      
      getTimeWindow() {
        return this.timeWindow;
      }
      
      updateUI() {
        const speedDisplay = document.getElementById('speed-display');
        const timeDisplay = document.getElementById('time-display');
        
        if (speedDisplay) {
          speedDisplay.textContent = `${this.speedMultiplier.toFixed(1)}x`;
        }
        if (timeDisplay) {
          timeDisplay.textContent = `${this.timeWindow.toFixed(1)}s`;
        }
      }
      
      stop() {
        if (this.speedTimer) {
          clearInterval(this.speedTimer);
          this.speedTimer = null;
        }
      }
      
      getStats() {
        return {
          maxSpeed: this.speedMultiplier,
          timeSurvived: (Date.now() - this.lastWordTime) / 1000
        };
      }
    }

    // Global Leaderboard Manager
    class LeaderboardManager {
      constructor() {
        this.apiUrl = 'https://api.jsonbin.io/v3/b/your-leaderboard-bin-id'; // Replace with actual API
        this.apiKey = 'your-api-key'; // Replace with actual API key
      }
      
      async submitScore(score, timeSurvived, maxSpeed) {
        try {
          const playerName = this.getPlayerName();
          const entry = {
            name: playerName,
            score: score,
            timeSurvived: timeSurvived,
            maxSpeed: maxSpeed,
            timestamp: Date.now()
          };
          
          // For now, store locally and simulate API call
          const leaderboard = this.getLocalLeaderboard();
          leaderboard.push(entry);
          leaderboard.sort((a, b) => b.score - a.score);
          leaderboard.splice(10); // Keep only top 10
          localStorage.setItem('fallphabet_leaderboard', JSON.stringify(leaderboard));
          
          return true;
        } catch (error) {
          console.error('Failed to submit score:', error);
          return false;
        }
      }
      
      async getLeaderboard() {
        try {
          // For now, return local leaderboard
          return this.getLocalLeaderboard();
        } catch (error) {
          console.error('Failed to get leaderboard:', error);
          return [];
        }
      }
      
      getLocalLeaderboard() {
        return JSON.parse(localStorage.getItem('fallphabet_leaderboard') || '[]');
      }
      
      getPlayerName() {
        let name = localStorage.getItem('fallphabet_player_name');
        if (!name) {
          name = prompt('Enter your name for the leaderboard:') || 'Anonymous';
          localStorage.setItem('fallphabet_player_name', name);
        }
        return name;
      }
      
      renderLeaderboard() {
        const content = document.getElementById('leaderboard-content');
        this.getLeaderboard().then(leaderboard => {
          if (leaderboard.length === 0) {
            content.innerHTML = '<div class="loading">No scores yet. Be the first!</div>';
            return;
          }
          
          content.innerHTML = leaderboard.map((entry, index) => 
            '<div class="leaderboard-entry">' +
              '<div class="leaderboard-rank">#' + (index + 1) + '</div>' +
              '<div class="leaderboard-name">' + entry.name + '</div>' +
              '<div class="leaderboard-score">' + entry.score + '</div>' +
              '<div class="leaderboard-time">' + entry.maxSpeed.toFixed(1) + 'x</div>' +
            '</div>'
          ).join('');
        });
      }
    }

    // TileSpawner Module
    class TileSpawner {
      constructor(scene, gridX, gridY, gridWidth, gridHeight, columns, rows) {
        this.scene = scene;
        this.gridX = gridX;
        this.gridY = gridY;
        this.gridWidth = gridWidth;
        this.gridHeight = gridHeight;
        this.columns = columns;
        this.rows = rows;
        this.tileSize = (this.gridWidth / this.columns) * 0.75; // Smaller tiles for more margin
        this.tileMargin = (this.gridWidth / this.columns - this.tileSize) / 2; // Larger margin
        // Reduce the vertical gap between tiles
        this.tileSpacing = 8; // Reduced from 24 to 8 for tighter vertical spacing
        this.fallSpeed = 150; // pixels/sec, smoother and more playable
        this.letters = {
          'E': 10, 'A': 8, 'I': 7, 'N': 6, 'O': 7, 'R': 6, 'T': 6, 'L': 5, 'S': 5, 'U': 4,
          'D': 4, 'P': 3, 'M': 3, 'H': 3, 'G': 3, 'B': 3, 'F': 3, 'Y': 2, 'W': 2, 'K': 2,
          'V': 2, 'X': 1, 'Z': 1, 'J': 1, 'Q': 1, 'C': 4
        };
        this.letterPool = [];
        this.buildLetterPool();
        // Each column has a queue of falling tiles
        this.columnsTiles = Array.from({length: columns}, () => []);
        this.columnX = [];
        for (let i = 0; i < columns; i++) {
          this.columnX.push(gridX + (i + 0.5) * (gridWidth / columns));
        }
        // Set up per-column spawn timers for natural cascade
        this.columnTimers = [];
        this.fixedSpawnInterval = 1000; // ms, fixed interval after first tile
        for (let col = 0; col < this.columns; col++) {
          let isFirstSpawn = true;
          const spawnNext = () => {
            // Only spawn if last tile is far enough down
            const colTiles = this.columnsTiles[col];
            const lastTile = colTiles.length > 0 ? colTiles[colTiles.length - 1] : null;
            const spawnY = this.gridY - this.tileSize / 2;
            let requiredSpacing = this.tileSize + this.tileSpacing;
            if (lastTile && lastTile.y < spawnY + requiredSpacing) {
              // Not enough space, retry soon
              this.columnTimers[col] = this.scene.time.addEvent({
                delay: 100,
                callback: spawnNext,
                callbackScope: this
              });
              return;
            }
            const tile = this.spawnTile(col, spawnY);
            this.columnsTiles[col].push(tile);
            // Schedule the next spawn
            let delay;
            if (isFirstSpawn) {
              // Only the first spawn is randomized
              delay = Phaser.Math.Between(900, 1200);
              isFirstSpawn = false;
            } else {
              delay = this.fixedSpawnInterval;
            }
            this.columnTimers[col] = this.scene.time.addEvent({
              delay: delay,
              callback: spawnNext,
              callbackScope: this
            });
          };
          // Start the first spawn with a unique random initial delay per column
          let initialDelay = Phaser.Math.Between(0, 800);
          if (col === 0) initialDelay += 200; // Delay column 1 by 0.2s
          if (col === 1) initialDelay = Math.max(0, initialDelay - 800); // Column 2 spawns 0.8s earlier
          if (col === 3) initialDelay += 800; // Delay column 4 by 0.8s
          if (col === 4) initialDelay += 1200; // Delay column 5 by 1.2s
          this.scene.time.addEvent({
            delay: initialDelay,
            callback: spawnNext,
            callbackScope: this
          });
        }
      }
      
      buildLetterPool() {
        for (const [letter, freq] of Object.entries(this.letters)) {
          for (let i = 0; i < freq; i++) this.letterPool.push(letter);
        }
      }
      
      getRandomLetter() {
        return this.letterPool[Math.floor(Math.random() * this.letterPool.length)];
      }
      
      spawnTile(col, y) {
        const letter = this.getRandomLetter();
        const x = this.columnX[col];
        // Shadow (subtle, larger, more transparent)
        const shadow = this.scene.add.rectangle(x + 3, y + 6, this.tileSize + 4, this.tileSize + 4, 0xC2A477, 0.18);
        shadow.setDepth(0);
        // Main tile (rounded rectangle)
        const tile = this.scene.add.rectangle(x, y, this.tileSize, this.tileSize, 0xFFF5E1);
        tile.setStrokeStyle(3, 0xB8860B);
        tile.setDepth(1);
        tile.setInteractive();
        tile.isScrabbleTile = true;
        tile.radius = 12;
        // Inner shadow (drawn as a slightly smaller, semi-transparent rectangle)
        const innerShadow = this.scene.add.rectangle(x, y, this.tileSize - 6, this.tileSize - 6, 0x8B6B2F, 0.08);
        innerShadow.setDepth(2);
        // Letter text
        const text = this.scene.add.text(x, y, letter, {
          fontFamily: 'Inter', fontSize: '64px', color: '#222', fontStyle: 'normal', fontWeight: '300',
        }).setOrigin(0.5);
        text.setDepth(3);
        text.setShadow(2, 3, '#B8860B', 2, false, true);
        // Apply the grid mask to all tile elements
        const mask = this.scene.gridMask;
        tile.setMask(mask);
        text.setMask(mask);
        shadow.setMask(mask);
        innerShadow.setMask(mask);
        tile.letter = letter;
        tile.text = text;
        tile.col = col;
        tile.falling = true;
        tile.shadow = shadow;
        tile.innerShadow = innerShadow;
        // Add a subtle spawn animation
        tile.setScale(0.85);
        text.setScale(0.85);
        shadow.setScale(0.85);
        innerShadow.setScale(0.85);
        this.scene.tweens.add({
          targets: [tile, text, shadow, innerShadow],
          scaleX: 1,
          scaleY: 1,
          duration: 300,
          ease: 'Back.easeOut'
        });
        return tile;
      }
      
      update(dt) {
        // Update fall speed based on current mode
        if (this.scene.gameModeManager && this.scene.gameModeManager.getCurrentMode().speedIncrease) {
          this.fallSpeed = this.scene.taptileSpeedManager.getCurrentSpeed();
        }
        
        for (let col = 0; col < this.columns; col++) {
          let colTiles = this.columnsTiles[col];
          for (let i = 0; i < colTiles.length; i++) {
            const tile = colTiles[i];
            if (!tile.falling) continue;
            tile.y += this.fallSpeed * dt;
            tile.text.y = tile.y;
            if (tile.shadow) tile.shadow.y = tile.y + 6;
            if (tile.innerShadow) tile.innerShadow.y = tile.y;
          }
          // Remove tiles with smooth slide-out animation
          for (let i = colTiles.length - 1; i >= 0; i--) {
            const tile = colTiles[i];
            if (tile.y + this.tileSize / 2 >= this.scene.playfieldBottomY) {
              this.scene.tweens.add({
                targets: [tile, tile.text, tile.shadow, tile.innerShadow],
                scaleX: 0.8,
                scaleY: 0.8,
                alpha: 0,
                duration: 200,
                ease: 'Power2',
                onComplete: () => {
                  tile.destroy();
                  tile.text.destroy();
                  if (tile.shadow) tile.shadow.destroy();
                  if (tile.innerShadow) tile.innerShadow.destroy();
                }
              });
              colTiles.splice(i, 1);
            }
          }
        }
      }
      
      getAllTiles() {
        return this.columnsTiles.flat();
      }
    }

    // InputHandler Module
    class InputHandler {
      constructor(scene, tileSpawner) {
        this.scene = scene;
        this.tileSpawner = tileSpawner;
        this.selectedTiles = [];
        this.buffer = [];
        this.isDragging = false;
        this.lastTile = null;
        this.lastTapTime = 0;
        this.lastTappedTile = null;
        this.autoClearTimeout = null;
        // Set up input events
        this.scene.input.on('pointerdown', this.onPointerDown, this);
        this.scene.input.on('pointermove', this.onPointerMove, this);
        this.scene.input.on('pointerup', this.onPointerUp, this);
        // Also allow tap-to-select
        this.scene.input.on('gameobjectdown', this.onTileTap, this);
      }
      
      onPointerDown(pointer) {
        this.isDragging = true;
        
        // Check if click is outside the grid area
        const x = pointer.x;
        const y = pointer.y;
        const isOutsideGrid = x < this.scene.gridX || 
                             x > this.scene.gridX + this.scene.gridWidth ||
                             y < this.scene.gridY || 
                             y > this.scene.gridY + this.scene.gridHeight;
        
        // If outside grid and we have selected tiles, clear the buffer
        if (isOutsideGrid && this.selectedTiles.length > 0) {
          this.clearBuffer();
          return;
        }
        
        // Only clear buffer if not already selecting
        if (!this.selectedTiles.length) this.clearBuffer();
        this.selectTileAt(pointer.x, pointer.y);
      }
      
      onPointerMove(pointer) {
        if (!this.isDragging) return;
        this.selectTileAt(pointer.x, pointer.y);
      }
      
      onPointerUp(pointer) {
        this.isDragging = false;
        // Do not clear buffer here; let user tap to build words
      }
      
      onTileTap(pointer, tile) {
        if (!tile || !tile.isScrabbleTile) return;
        
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        console.log(`Tile tap on ${isMobile ? 'mobile' : 'desktop'}:`, tile.letter, 'Buffer:', this.buffer.join(''));
        
        const now = Date.now();
        // Double-tap detection
        if (this.lastTappedTile === tile && (now - this.lastTapTime) < 350) {
          // Only submit if this tile is the last selected tile
          if (this.selectedTiles.length && this.selectedTiles[this.selectedTiles.length - 1] === tile) {
            console.log(`Double-tap detected, submitting word: ${this.buffer.join('')}`);
            this.submitWord();
            this.clearAutoClearTimer();
            return;
          }
        } else {
          if (!this.selectedTiles.includes(tile)) {
            this.selectedTiles.push(tile);
            this.buffer.push(tile.letter);
            this.highlightTile(tile, true);
            this.lastTile = tile;
            console.log(`Added tile ${tile.letter}, buffer now: ${this.buffer.join('')}`);
            // If this is the first tile of a new word, handle chain increment
            if (this.selectedTiles.length === 1 && this.scene.chainTracker && this.scene.chainTracker.chainWindowActive) {
              this.scene.chainTracker.shouldIncrementChain = true;
              this.scene.chainTracker.clearChainWindow();
            }
          }
        }
        this.lastTappedTile = tile;
        this.lastTapTime = now;
        this.resetAutoClearTimer();
      }
      
      selectTileAt(x, y) {
        const tiles = this.tileSpawner.getAllTiles();
        for (const tile of tiles) {
          if (!tile || tile.destroyed || !tile.isScrabbleTile) continue;
          const distance = Phaser.Math.Distance.Between(x, y, tile.x, tile.y);
          if (distance <= tile.width / 2) {
            if (this.lastTile && tile !== this.lastTile) {
              // Check if this tile is adjacent to the last selected tile
              const lastCol = this.lastTile.col;
              const currentCol = tile.col;
              const lastIndex = this.tileSpawner.columnsTiles[lastCol].indexOf(this.lastTile);
              const currentIndex = this.tileSpawner.columnsTiles[currentCol].indexOf(tile);
              const isAdjacent = (
                (Math.abs(currentCol - lastCol) === 1 && Math.abs(currentIndex - lastIndex) <= 1) ||
                (currentCol === lastCol && Math.abs(currentIndex - lastIndex) === 1)
              );
              if (!isAdjacent) continue;
            }
            if (!this.selectedTiles.includes(tile)) {
              this.selectedTiles.push(tile);
              this.buffer.push(tile.letter);
              this.highlightTile(tile, true);
            }
            this.lastTile = tile;
            break;
          }
        }
      }
      
      highlightTile(tile, highlight) {
        if (!tile || tile.destroyed) return;
        if (highlight) {
          tile.setFillStyle(0x90EE90); // Light green
          tile.setStrokeStyle(3, 0x228B22); // Dark green border
          if (tile.text && !tile.text.destroyed) tile.text.setColor('#006400');
        } else {
          tile.setFillStyle(0xFFF5E1); // Original color
          tile.setStrokeStyle(3, 0xB8860B); // Original border
          if (tile.text && !tile.text.destroyed) tile.text.setColor('#222');
        }
      }
      
      resetAutoClearTimer() {
        this.clearAutoClearTimer();
        this.autoClearTimeout = setTimeout(() => {
          this.clearBuffer();
        }, 1250); // 1.25 seconds
      }

      clearAutoClearTimer() {
        if (this.autoClearTimeout) {
          clearTimeout(this.autoClearTimeout);
          this.autoClearTimeout = null;
        }
      }

      clearBuffer() {
        this.selectedTiles.forEach(tile => {
          // Destroy tiles when clearing buffer (not successful word submission)
          if (tile && !tile.destroyed) {
            tile.destroy();
            if (tile.text && !tile.text.destroyed) tile.text.destroy();
            if (tile.shadow && !tile.shadow.destroyed) tile.shadow.destroy();
            if (tile.innerShadow && !tile.innerShadow.destroyed) tile.innerShadow.destroy();
          }
        });
        this.selectedTiles = [];
        this.buffer = [];
        this.lastTile = null;
        this.clearAutoClearTimer();
      }
      
      submitWord() {
        if (this.buffer.length < 2) return;
        const word = this.buffer.join('');
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        console.log(`submitWord called on ${isMobile ? 'mobile' : 'desktop'}: "${word}" with ${this.selectedTiles.length} tiles`);
        this.scene.events.emit('wordSubmitted', {
          word: word,
          tiles: [...this.selectedTiles]
        });
        this.clearBuffer();
      }
      
      update() {
        // Any per-frame updates if needed
      }
    }

    // WordValidator Module
    class WordValidator {
      constructor() {
        this.dictionary = new Set();
        this.loadDictionary();
      }
      
      async loadDictionary() {
        // This class is no longer used for validation - we use the free dictionary API instead
        console.log('WordValidator: Using free dictionary API for validation');
      }
      
      async validate(word) {
        // This method is no longer used - we use the free dictionary API instead
        return false;
      }
    }

    // ScoreManager Module
    class ScoreManager {
      constructor() {
        this.totalScore = 0;
        this.letterScores = {
          'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1, 'F': 4, 'G': 2, 'H': 4, 'I': 1, 'J': 8,
          'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1, 'P': 3, 'Q': 10, 'R': 1, 'S': 1, 'T': 1,
          'U': 1, 'V': 4, 'W': 4, 'X': 8, 'Y': 4, 'Z': 10
        };
      }
      
      calculateScore(word, chainMultiplier = 1) {
        let score = 0;
        for (const letter of word.toUpperCase()) {
          score += this.letterScores[letter] || 0;
        }
        return score * chainMultiplier;
      }
      
      addScore(points) {
        this.totalScore += points;
      }
      
      getTotalScore() {
        return this.totalScore;
      }
    }

    // ChainTracker Module
    class ChainTracker {
      constructor() {
        this.chainLevel = 1;
        this.highestChain = 1;
        this.lastWordTime = 0;
        this.chainWindowDuration = 1250; // 1.25 seconds
        this.chainWindowTimeout = null;
        this.chainWindowActive = false;
        this.shouldIncrementChain = false;
      }
      
      startChainWindow() {
        this.clearChainWindow();
        this.chainWindowActive = true;
        this.shouldIncrementChain = false;
        this.chainWindowTimeout = setTimeout(() => {
          this.resetChain();
          this.chainWindowActive = false;
          this.shouldIncrementChain = false;
          if (window && window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
            const scene = window.game.scene.keys['GameScene'];
            if (scene.updateUI) scene.updateUI();
          }
        }, this.chainWindowDuration);
      }
      
      clearChainWindow() {
        if (this.chainWindowTimeout) {
          clearTimeout(this.chainWindowTimeout);
          this.chainWindowTimeout = null;
        }
        this.chainWindowActive = false;
      }
      
      incrementOnNextWord() {
        this.chainLevel++;
        if (this.chainLevel > this.highestChain) this.highestChain = this.chainLevel;
        this.clearChainWindow();
      }
      
      resetChain() {
        this.chainLevel = 1;
        this.clearChainWindow();
        if (window && window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
          const scene = window.game.scene.keys['GameScene'];
          if (scene.updateUI) scene.updateUI();
        }
      }
      
      getChainLevel() {
        return this.chainLevel;
      }
      getHighestChain() {
        return this.highestChain;
      }
    }

    // --- Daily Challenge Manager ---
    class DailyChallengeManager {
      constructor() {
        this.today = this.getTodayString();
        this.load();
      }
      getTodayString() {
        const now = new Date();
        return `${now.getFullYear()}-${now.getMonth()+1}-${now.getDate()}`;
      }
      load() {
        const data = JSON.parse(localStorage.getItem('fallphabet_daily') || '{}');
        if (data.date !== this.today) {
          this.attempts = 0;
          this.save();
        } else {
          this.attempts = data.attempts || 0;
        }
      }
      save() {
        localStorage.setItem('fallphabet_daily', JSON.stringify({ date: this.today, attempts: this.attempts }));
      }
      incrementAttempt() {
        this.attempts++;
        this.save();
      }
      canRetry() {
        this.load();
        return this.attempts < 2;
      }
      attemptsLeft() {
        this.load();
        return Math.max(0, 2 - this.attempts);
      }
    }

    // GameScene
    class GameScene extends Phaser.Scene {
      constructor() {
        super({ key: 'GameScene' });
        // Change columns to 5 for a 5-column grid
        this.columns = 5;
        // Recalculate tile size and margin for 5 columns, keeping the same margin formula
        this.tileSize = (this.gridWidth / this.columns) * 0.75; // Keep the same 75% sizing
        this.tileMargin = (this.gridWidth / this.columns - this.tileSize) / 2;
        // Recalculate column positions for 5 columns
        this.columnX = [];
        for (let i = 0; i < this.columns; i++) {
          this.columnX.push(this.gridX + (i + 0.5) * (this.gridWidth / this.columns));
        }
        this.rows = 12;
        this.wordsUsed = 0;
        this.topWord = '';
        this.topWordScore = 0;
        this.highestChain = 1;
        this.gameOver = false;
        this.scoredWords = [];
        this.gameStartTime = 0;
      }
      
      create() {
        console.log('Creating GameScene...');
        
        // Calculate playfield dimensions
        const playfieldWidth = 800; // Match Phaser config and container
        const playfieldHeight = 1200; // Match Phaser config height
        this.gridX = 50;
        this.gridY = 50;
        this.gridWidth = playfieldWidth - 100;
        this.gridHeight = playfieldHeight - 100;
        this.playfieldBottomY = this.gridY + this.gridHeight;
        
        // Create grid outline
        this.grid = this.add.rectangle(
          this.gridX + this.gridWidth / 2,
          this.gridY + this.gridHeight / 2,
          this.gridWidth,
          this.gridHeight,
          0xFFFFFF,
          0
        );
        this.grid.setStrokeStyle(3, 0x000000);
        
        // Create a geometry mask for the playfield
        const maskShape = this.add.graphics();
        maskShape.fillStyle(0xffffff);
        maskShape.fillRect(this.gridX, this.gridY, this.gridWidth, this.gridHeight);
        this.gridMask = maskShape.createGeometryMask();
        
        // Add column dividers for better visual separation
        for (let i = 1; i < this.columns; i++) {
          const dividerX = this.gridX + (i * this.gridWidth / this.columns);
          this.add.line(dividerX, this.gridY, dividerX, this.gridY + this.gridHeight, 0x8B4513, 2);
        }
        
        // Initialize modules
        console.log('Initializing modules...');
        this.tileSpawner = new TileSpawner(this, this.gridX, this.gridY, this.gridWidth, this.gridHeight, this.columns, this.rows);
        
        this.inputHandler = new InputHandler(this, this.tileSpawner);
        this.wordValidator = new WordValidator();
        this.scoreManager = new ScoreManager();
        this.chainTracker = new ChainTracker();
        
        // Initialize mode managers
        this.gameModeManager = window.gameModeManager || new GameModeManager();
        this.taptileSpeedManager = new TaptileSpeedManager();
        this.leaderboardManager = new LeaderboardManager();
        
        // Game state
        this.wordsUsed = 0;
        this.topWord = '';
        this.topWordScore = 0;
        this.highestChain = 1;
        this.gameOver = false;
        this.gameStartTime = Date.now();
        
        // Start taptile mode if active
        if (this.gameModeManager.getCurrentMode().speedIncrease) {
          this.taptileSpeedManager.start();
        }
        
        // Listen for word submissions
        this.events.on('wordSubmitted', this.handleWordSubmission, this);
        
        console.log('GameScene create completed');

        // Add bottom border line
        this.add.line(
          this.gridX,
          this.gridY + this.gridHeight,
          this.gridX + this.gridWidth,
          this.gridY + this.gridHeight,
          0x000000,
          1
        ).setOrigin(0, 0).setLineWidth(3).setDepth(100);

        this.dailyChallenge = new DailyChallengeManager();
      }

      update(time, delta) {
        if (this.gameOver) return;
        const dt = delta / 1000;
        this.tileSpawner.update(dt);
        this.inputHandler.update();
        
        // Check taptile time window
        if (this.gameModeManager && this.gameModeManager.getCurrentMode().speedIncrease) {
          if (!this.taptileSpeedManager.checkTimeWindow() && this.wordsUsed > 0) {
            this.endGame();
            return;
          }
        }
        
        this.updateUI();
      }
      
      async handleWordSubmission(data) {
        if (this.gameOver) return;
        const { word, tiles } = data;
        // Always clean up tiles from spawner tracking, regardless of validation result
        tiles.forEach(tile => {
          if (tile && tile.col !== undefined && this.tileSpawner.columnsTiles[tile.col]) {
            const colIndex = this.tileSpawner.columnsTiles[tile.col].indexOf(tile);
            if (colIndex > -1) {
              this.tileSpawner.columnsTiles[tile.col].splice(colIndex, 1);
            }
          }
        });
        // Strict English word validation
        let isValid = false;
        let isProper = false;
        let apiFailed = false;
        
        try {
          const controller = new AbortController();
          // Longer timeout for mobile devices
          const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
          const timeout = isMobile ? 10000 : 5000; // 10 seconds on mobile, 5 on desktop
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          console.log(`Validating word "${word}" on ${isMobile ? 'mobile' : 'desktop'} with ${timeout}ms timeout`);
          
          const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word.toLowerCase()}`, {
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          
          if (res.ok) {
            const data = await res.json();
            if (Array.isArray(data)) {
              // Check all meanings for proper noun
              isProper = data.some(entry =>
                entry.meanings && entry.meanings.some(meaning =>
                  meaning.partOfSpeech && meaning.partOfSpeech.toLowerCase().includes('proper')
                )
              );
              isValid = true;
              console.log(`Word "${word}" validated successfully`);
            }
          } else {
            console.log(`API returned status ${res.status} for word "${word}"`);
            apiFailed = true;
          }
        } catch (e) {
          console.log(`API call failed for "${word}":`, e.message);
          apiFailed = true;
        }
        
        // No fallback - only use the free dictionary API
        if (apiFailed) {
          isValid = false;
        }
        if (!isValid) {
          this.showFlashMessage(`"${word}" - Not a valid English word!`, '#ff6b6b');
          return;
        }
        if (isProper) {
          this.showFlashMessage(`"${word}" is a proper name. No proper names allowed!`, '#ff6b6b');
          return;
        }
        
        // Haptic feedback for successful word submission (temporarily disabled for mobile debugging)
        // if ('vibrate' in navigator) {
        //   navigator.vibrate(100); // Short vibration for success
        // }
        
        // If valid and not a proper noun, continue with scoring and animation
        console.log(`Starting scoring process for word "${word}"`);
        const chainLevel = this.chainTracker.getChainLevel();
        console.log(`Chain level: ${chainLevel}`);
        const score = this.scoreManager.calculateScore(word, chainLevel);
        console.log(`Calculated score: ${score}`);
        this.scoreManager.addScore(score);
        console.log(`Total score after adding: ${this.scoreManager.getTotalScore()}`);
        this.wordsUsed++;
        console.log(`Words used: ${this.wordsUsed}`);
        if (score > this.topWordScore) {
          this.topWordScore = score;
          this.topWord = word;
        }
        this.chainTracker.incrementOnNextWord();
        const chainText = chainLevel > 1 ? ` (x${chainLevel} chain!)` : '';
        this.showFlashMessage(`"${word}" - ${score} pts${chainText}`, '#51cf66');
        this.scoredWords.push({ word, score });
        tiles.forEach(tile => {
          this.tweens.add({
            targets: [tile, tile.text, tile.shadow, tile.innerShadow],
            scaleX: 0,
            scaleY: 0,
            duration: 300,
            ease: 'Power2',
            onComplete: () => {
              tile.destroy();
              if (tile.text) tile.text.destroy();
              if (tile.shadow) tile.shadow.destroy();
              if (tile.innerShadow) tile.innerShadow.destroy();
            }
          });
        });
        // Check for game over based on mode
        const currentMode = this.gameModeManager.getCurrentMode();
        if (currentMode.goal && this.scoreManager.getTotalScore() >= currentMode.goal) {
          this.endGame();
        }
        
        // Update taptile speed manager
        if (currentMode.speedIncrease) {
          this.taptileSpeedManager.onWordSubmitted();
        }
        
        // Always start chain window after word submission
        this.chainTracker.startChainWindow();
      }
      
      showFlashMessage(message, color = '#fff') {
        const flashElement = document.getElementById('flash-message');
        flashElement.textContent = message;
        flashElement.style.color = color;
        flashElement.style.display = 'block';
        
        setTimeout(() => {
          flashElement.style.display = 'none';
        }, 2000);
      }
      
      updateUI() {
        // Update HTML elements instead of Phaser text
        const scoreDisplay = document.getElementById('score-display');
        const chainDisplay = document.getElementById('chain-display');
        
        const currentScore = this.scoreManager.getTotalScore();
        const currentChain = this.chainTracker.getChainLevel();
        
        console.log(`updateUI called - Score: ${currentScore}, Chain: ${currentChain}`);
        
        scoreDisplay.textContent = currentScore;
        scoreDisplay.style.fontFamily = 'Arial, Helvetica, sans-serif';
        
        chainDisplay.textContent = `x${currentChain}`;
        chainDisplay.style.fontFamily = 'Arial, Helvetica, sans-serif';
        
        // Check for game over immediately when score reaches 200
        if (this.scoreManager.getTotalScore() >= 200 && !this.gameOver) {
          this.endGame();
        }

        // Add a container for the word list
        const modalStats = document.querySelector('.modal-stats');
        let wordListDiv = document.getElementById('modal-word-list');
        if (!wordListDiv) {
          wordListDiv = document.createElement('div');
          wordListDiv.id = 'modal-word-list';
          wordListDiv.style.maxHeight = '160px';
          wordListDiv.style.overflowY = 'auto';
          wordListDiv.style.margin = '18px 0 0 0';
          wordListDiv.style.textAlign = 'left';
          wordListDiv.style.fontSize = '1.05rem';
          wordListDiv.style.lineHeight = '1.4';
          wordListDiv.style.background = '#fff9ef';
          wordListDiv.style.border = '1px solid #e5c9a8';
          wordListDiv.style.borderRadius = '8px';
          wordListDiv.style.padding = '10px 12px';
          modalStats.parentNode.insertBefore(wordListDiv, modalStats.nextSibling);
        }
        // Populate the list on win
        if (this.scoredWords && this.scoredWords.length) {
          wordListDiv.innerHTML = '<strong>Words you scored:</strong><ul style="margin:8px 0 0 0;padding:0;list-style:none;">' +
            this.scoredWords.map(w => `<li style='display:flex;justify-content:space-between;'><span>${w.word}</span><span style='color:#7c3aed;font-weight:bold;'>${w.score} pts</span></li>`).join('') +
            '</ul>';
        } else {
          wordListDiv.innerHTML = '';
        }
      }

      endGame() {
        this.gameOver = true;
        
        // Stop taptile speed manager
        if (this.taptileSpeedManager) {
          this.taptileSpeedManager.stop();
        }
        
        // Stop all timers in tileSpawner
        if (this.tileSpawner && this.tileSpawner.columnTimers) {
          this.tileSpawner.columnTimers.forEach(timer => { if (timer) timer.paused = true; });
        }
        
        const modal = document.getElementById('gameover-modal');
        const title = modal.querySelector('.modal-title');
        const stats = modal.querySelector('.modal-stats');
        const taptileStats = document.getElementById('taptile-modal-stats');
        const wordsUsed = this.wordsUsed;
        const topWord = this.topWord || '-';
        const topWordScore = this.topWordScore || 0;
        const highestChain = this.chainTracker && this.chainTracker.getHighestChain ? 'x' + this.chainTracker.getHighestChain() : '';
        const finalScore = this.scoreManager.getTotalScore();
        
        const currentMode = this.gameModeManager.getCurrentMode();
        
        if (currentMode.speedIncrease) {
          // Taptile mode
          const taptileStats = this.taptileSpeedManager.getStats();
          const timeSurvived = (Date.now() - this.gameStartTime) / 1000;
          
          if (title) title.textContent = 'Game Over!';
          if (stats) {
            stats.innerHTML = `<div><strong>Words Used:</strong> <span id="modal-words-used">${wordsUsed}</span></div><div><strong>Top Word:</strong> <span id="modal-top-word">${topWord}</span></div><div><strong>Highest Chain:</strong> <span id="modal-highest-chain">x${highestChain}</span></div>`;
          }
          
          // Show taptile specific stats
          const taptileModalStats = document.getElementById('taptile-modal-stats');
          if (taptileModalStats) {
            taptileModalStats.style.display = 'block';
            document.getElementById('modal-final-score').textContent = finalScore;
            document.getElementById('modal-max-speed').textContent = `${taptileStats.maxSpeed.toFixed(1)}x`;
            document.getElementById('modal-time-survived').textContent = `${timeSurvived.toFixed(1)}s`;
          }
          
          // Submit to leaderboard
          if (this.leaderboardManager) {
            this.leaderboardManager.submitScore(finalScore, timeSurvived, taptileStats.maxSpeed);
          }
          
          // Always show restart for taptile mode
          const restartBtn = document.getElementById('modal-restart-btn');
          restartBtn.textContent = 'Try Again';
          restartBtn.style.display = '';
          
        } else {
          // Daily challenge mode
          if (finalScore >= 200) {
            // Win condition
            if (title) title.textContent = 'You Did It!';
            if (stats) stats.innerHTML = `<span style="font-family: Arial, Helvetica, sans-serif; font-size: 1.2rem; color: #222; display: block;">It took you <strong>${wordsUsed}</strong> words to hit 200 points today.<br><br>Your Top Word was <strong>${topWord}</strong> earning you <strong>${topWordScore}</strong> points.<br><br>You chained <strong>${highestChain}</strong> words together today!<br><br>Come back tomorrow to see if you can beat your score.<br><br>Share with friends to see who can beat the Fallphabet with the fewest words.</span>`;
          } else {
            // Normal game over
            if (title) title.textContent = 'Game Over!';
            if (stats) {
              stats.innerHTML = `<div><strong>Words Used:</strong> <span id="modal-words-used">${wordsUsed}</span></div><div><strong>Top Word:</strong> <span id="modal-top-word">${topWord}</span></div><div><strong>Highest Chain:</strong> <span id="modal-highest-chain">x${highestChain}</span></div>`;
            }
          }
          
          // Hide taptile stats
          const taptileModalStats = document.getElementById('taptile-modal-stats');
          if (taptileModalStats) {
            taptileModalStats.style.display = 'none';
          }
          
          // Daily challenge logic for attempts/restart button
          this.dailyChallenge.incrementAttempt();
          const restartBtn = document.getElementById('modal-restart-btn');
          if (finalScore >= 200) {
            // For wins, always show Try Again button
            restartBtn.textContent = 'Try Again';
            restartBtn.style.display = '';
          } else if (this.dailyChallenge.attemptsLeft() > 0) {
            // For losses, only show if attempts remain
            restartBtn.textContent = 'Try Again';
            restartBtn.style.display = '';
          } else {
            restartBtn.style.display = 'none';
          }
          
          // Save game stats to localStorage
          saveGameToHistory({ date: this.dailyChallenge.today, wordsUsed, topWord, topWordScore, highestChain, score: finalScore, longestWord: this.topWord });
        }
        
        modal.classList.add('show');
      }
    }

    // Game Configuration
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 1200,
      backgroundColor: '#ffe5d9',
      parent: 'playfield-container',
      scene: [GameScene],
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 }, // Disable gravity, we'll control velocity manually
          debug: false,
        },
      },
    };

    // Start the game
    window.addEventListener('DOMContentLoaded', () => {
      console.log('DOM loaded, creating Phaser game...');
      
      // Initialize global game mode manager
      window.gameModeManager = new GameModeManager();
      
      try {
        window.game = new Phaser.Game(config);
        console.log('Phaser game created successfully');
        
        // Mode switching functionality
        const modeButtons = document.querySelectorAll('.mode-btn');
        modeButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const mode = btn.getAttribute('data-mode');
            window.gameModeManager.setMode(mode);
            
            // Restart game with new mode
            if (window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
              window.game.scene.restart();
            }
          });
        });
        
        // Leaderboard functionality
        const leaderboardBtn = document.getElementById('leaderboard-btn');
        const leaderboardModal = document.getElementById('leaderboard-modal');
        const leaderboardClose = document.getElementById('leaderboard-close');
        
        if (leaderboardBtn) {
          leaderboardBtn.addEventListener('click', () => {
            leaderboardModal.classList.add('show');
            if (window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
              const scene = window.game.scene.keys['GameScene'];
              if (scene.leaderboardManager) {
                scene.leaderboardManager.renderLeaderboard();
              }
            }
          });
        }
        
        if (leaderboardClose) {
          leaderboardClose.addEventListener('click', () => {
            leaderboardModal.classList.remove('show');
          });
        }
        
        // Dismiss leaderboard modal by clicking outside
        if (leaderboardModal) {
          leaderboardModal.addEventListener('click', e => {
            if (e.target === leaderboardModal) {
              leaderboardModal.classList.remove('show');
            }
          });
        }
        
        // Help button functionality
        const helpBtn = document.getElementById('help-btn');
        if (helpBtn) {
          helpBtn.onclick = () => {
            const modal = document.getElementById('instructions-modal');
            modal.style.display = 'flex';
            setTimeout(() => { modal.classList.add('show'); }, 10);
          };
        }
        
        // Instructions modal close button
        const instructionsCloseBtn = document.getElementById('instructions-close-btn');
        if (instructionsCloseBtn) {
          instructionsCloseBtn.onclick = () => {
            const modal = document.getElementById('instructions-modal');
            modal.style.display = 'none';
            modal.classList.remove('show');
          };
        }
        
        // Restart button functionality
        const restartBtn = document.getElementById('modal-restart-btn');
        if (restartBtn) {
          restartBtn.onclick = () => {
            const scene = window.game.scene.keys['GameScene'];
            const currentMode = window.gameModeManager.getCurrentMode();
            
            // Allow restart for taptile mode always, or for daily mode if conditions met
            if (currentMode.speedIncrease || 
                scene.scoreManager.getTotalScore() >= 200 || 
                (scene.dailyChallenge && scene.dailyChallenge.attemptsLeft() > 0)) {
              // Hide modal
              document.getElementById('gameover-modal').classList.remove('show');
              window.game.scene.restart();
            }
          };
        }

        // --- Enhanced Share button with Instagram Story support ---
        const shareBtn = document.getElementById('modal-share-btn');
        if (shareBtn) {
          shareBtn.onclick = async () => {
            // Check if user is on Instagram
            const isInstagram = /Instagram/.test(navigator.userAgent) || 
                               window.location.hostname.includes('instagram.com') ||
                               document.referrer.includes('instagram.com');
            
            if (isInstagram) {
              // Generate and download Instagram Story image
              let wordsUsed = '';
              let highestChain = '';
              let topWord = '';
              let topWordScore = '';
              if (window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
                const scene = window.game.scene.keys['GameScene'];
                wordsUsed = scene.wordsUsed || '';
                highestChain = scene.chainTracker && scene.chainTracker.getHighestChain ? 'x' + scene.chainTracker.getHighestChain() : '';
                topWord = scene.topWord || '';
                topWordScore = scene.topWordScore || '';
              }
              // Create canvas
              const bg = new Image();
              bg.src = 'fallphabet-og.png';
              await new Promise(res => { bg.onload = res; });
              const canvas = document.createElement('canvas');
              canvas.width = 1080;
              canvas.height = 1920;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
              ctx.font = 'bold 90px Montserrat, Arial, sans-serif';
              ctx.fillStyle = '#7c3aed';
              ctx.textAlign = 'center';
              ctx.fillText('FALLPHABET', canvas.width/2, 350);
              ctx.font = '48px Arial, Helvetica, sans-serif';
              ctx.fillStyle = '#222';
              ctx.fillText(`It took me ${wordsUsed} words`, canvas.width/2, 600);
              ctx.fillText(`Top word: ${topWord} (${topWordScore} pts)`, canvas.width/2, 700);
              ctx.fillText(`Top chain: ${highestChain}`, canvas.width/2, 800);
              ctx.font = '40px Arial, Helvetica, sans-serif';
              ctx.fillStyle = '#7c3aed';
              ctx.fillText('fallphabet.com', canvas.width/2, 1800);
              // Download image
              const url = canvas.toDataURL('image/png');
              const a = document.createElement('a');
              a.href = url;
              a.download = 'fallphabet-story.png';
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              alert('Image downloaded! Open Instagram, swipe up to add a story, and select the image from your camera roll.');
              return;
            }
            
            // Regular sharing logic
            let wordsUsed = '';
            let highestChain = '';
            // Try to get from GameScene if available
            if (window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
              const scene = window.game.scene.keys['GameScene'];
              wordsUsed = scene.wordsUsed || '';
              highestChain = scene.chainTracker && scene.chainTracker.getHighestChain ? 'x' + scene.chainTracker.getHighestChain() : '';
            }
            // Fallback to DOM if needed
            if (!wordsUsed) {
              const modal = document.getElementById('gameover-modal');
              wordsUsed = modal.querySelector('#modal-words-used')?.textContent || '';
            }
            if (!highestChain) {
              const modal = document.getElementById('gameover-modal');
              highestChain = modal.querySelector('#modal-highest-chain')?.textContent || '';
            }
            // Try Web Share API first
            if (navigator.share) {
              const shareText = `It took me ${wordsUsed} words with a top chain of ${highestChain} to beat the Fallphabet today! Think you can beat me?`;
              navigator.share({
                title: 'Fallphabet',
                text: shareText,
                url: 'https://fallphabet.com'
              });
            } else {
              // Fallback: open iMessage/SMS if on iOS, else copy to clipboard
              const shareText = `It took me ${wordsUsed} words with a top chain of ${highestChain} to beat the Fallphabet today! Think you can beat me? https://fallphabet.com`;
              const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
              if (isiOS) {
                window.location.href = `sms:&body=${encodeURIComponent(shareText)}`;
              } else {
                navigator.clipboard.writeText(shareText);
                alert('Share text copied to clipboard!');
              }
            }
          };
        }

        // Modal close button logic
        const closeBtn = document.getElementById('modal-close-btn');
        if (closeBtn) {
          closeBtn.onclick = () => {
            document.getElementById('gameover-modal').classList.remove('show');
          };
        }

        // Top menu modal logic
        const howtoBtn = document.getElementById('howto-btn');
        const statsBtn = document.getElementById('stats-btn');
        const howtoModal = document.getElementById('howto-modal');
        const statsModal = document.getElementById('stats-modal');
        const howtoClose = document.getElementById('howto-close');
        const statsClose = document.getElementById('stats-close');
        howtoBtn.onclick = () => { howtoModal.classList.add('show'); };
        statsBtn.onclick = () => { statsModal.classList.add('show'); renderStatsHistory(); };
        howtoClose.onclick = () => { howtoModal.classList.remove('show'); };
        statsClose.onclick = () => { statsModal.classList.remove('show'); };
        // Dismiss modals by clicking outside or swiping down
        [howtoModal, statsModal].forEach(modal => {
          modal.addEventListener('click', e => { if (e.target === modal) modal.classList.remove('show'); });
          // Optional: add swipe down to close for mobile
        });
      } catch (error) {
        console.error('Error creating Phaser game:', error);
      }
    });

    // --- Clean, robust chain logic for unlimited chaining ---
    // Patch ChainTracker.resetChain to always set chainLevel = 1 and update UI
    ChainTracker.prototype.resetChain = function() {
      this.chainLevel = 1;
      this.clearChainWindow();
      if (window && window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
        const scene = window.game.scene.keys['GameScene'];
        if (scene.updateUI) scene.updateUI();
      }
    };
    // Patch ChainTracker.startChainWindow to always reset flag and start timer
    ChainTracker.prototype.startChainWindow = function() {
      this.clearChainWindow();
      this.chainWindowActive = true;
      this.shouldIncrementChain = false;
      this.chainWindowTimeout = setTimeout(() => {
        this.resetChain();
        this.chainWindowActive = false;
        this.shouldIncrementChain = false;
      }, this.chainWindowDuration);
    };
    // Patch ChainTracker.clearChainWindow to always clear timer and active state
    ChainTracker.prototype.clearChainWindow = function() {
      if (this.chainWindowTimeout) {
        clearTimeout(this.chainWindowTimeout);
        this.chainWindowTimeout = null;
      }
      this.chainWindowActive = false;
    };
    // Patch InputHandler.onTileTap to set flag and clear timer on first tile of new word
    const origOnTileTapFinal = InputHandler.prototype.onTileTap;
    InputHandler.prototype.onTileTap = function(pointer, tile) {
      if (!tile || !tile.isScrabbleTile) return origOnTileTapFinal.call(this, pointer, tile);
      if (this.selectedTiles.length === 0 && this.scene.chainTracker && this.scene.chainTracker.chainWindowActive) {
        this.scene.chainTracker.shouldIncrementChain = true;
        this.scene.chainTracker.clearChainWindow();
      }
      return origOnTileTapFinal.call(this, pointer, tile);
    };
    // Patch GameScene.handleWordSubmission to increment chain if flag is set, always clear flag, always start new window
    const origHandleWordSubmissionFinal = GameScene.prototype.handleWordSubmission;
    GameScene.prototype.handleWordSubmission = async function(data) {
      if (this.gameOver) return;
      await origHandleWordSubmissionFinal.call(this, data);
      if (this.chainTracker.shouldIncrementChain) {
        this.chainTracker.chainLevel++;
        if (this.chainTracker.chainLevel > this.chainTracker.highestChain) this.chainTracker.highestChain = this.chainTracker.chainLevel;
        this.chainTracker.shouldIncrementChain = false;
      }
      this.chainTracker.startChainWindow();
    };

    // Find the container width dynamically for gridWidth
    const getPlayfieldWidth = () => {
      const container = document.getElementById('playfield-container');
      if (!container) return 480;
      const style = window.getComputedStyle(container);
      const padding = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
      return container.clientWidth - padding;
    };

    // In the Phaser game config or GameScene, use getPlayfieldWidth() for gridWidth
    // Example (pseudo):
    // const gridWidth = getPlayfieldWidth();
    // ... pass gridWidth to TileSpawner and grid drawing logic ...

    function renderStatsHistory() {
      const history = JSON.parse(localStorage.getItem('fallphabetHistory') || '[]');
      const statsDiv = document.getElementById('stats-history-content');
      if (!history.length) {
        statsDiv.innerHTML = '<p>No games played yet.</p>';
        return;
      }
      // Calculate best stats
      const fewestWords = Math.min(...history.map(h => h.wordsUsed));
      const highestScore = Math.max(...history.map(h => h.score ?? 0));
      let longestWord = '';
      history.forEach(h => {
        if (h.longestWord && h.longestWord.length > longestWord.length) longestWord = h.longestWord;
      });
      // Render summary
      statsDiv.innerHTML = `
        <div style='margin-bottom:18px;'>
          <strong>Best (fewest) words to win:</strong> ${fewestWords}<br/>
          <strong>Highest score:</strong> ${highestScore}<br/>
          <strong>Longest word ever:</strong> <span style='color:#7c3aed;font-weight:bold;'>${longestWord || '-'}</span>
        </div>
        <div style='font-size:1.05rem;'><strong>Recent Games:</strong></div>
        <ul style='margin:8px 0 0 0;padding:0;list-style:none;max-height:180px;overflow-y:auto;'>
          ${history.slice(-10).reverse().map(h =>
            `<li style='margin-bottom:8px;'><span style='color:#7c3aed;font-weight:bold;'>${h.date}</span>: ${h.wordsUsed} words, Top: ${h.topWord || '-'} (${h.topWordScore || 0} pts), Longest: ${h.longestWord || '-'}, Score: ${h.score ?? 0}</li>`
          ).join('')}
        </ul>
      `;
    }

    function saveGameToHistory(stats) {
      const history = JSON.parse(localStorage.getItem('fallphabetHistory') || '[]');
      history.push(stats);
      localStorage.setItem('fallphabetHistory', JSON.stringify(history));
    }
  </script>
</body>
</html>
