<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>FALLPHABET</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="style.css?v=107">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js?v=1"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="supabase-config.js"></script>
  <script src="leaderboard-integration.js"></script>
  <!-- Open Graph and Twitter Card for social sharing -->
  <meta property="og:title" content="Fallphabet" />
  <meta property="og:description" content="Try to win with as few words as possible!" />
  <meta property="og:image" content="/fallphabet-og.png" />
  <meta property="og:image:alt" content="FALLPHABET - Try to win with as few words as possible!" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://fallphabet.com" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Fallphabet" />
  <meta name="twitter:description" content="Try to win with as few words as possible!" />
  <meta name="twitter:image" content="/fallphabet-og.png" />
  <meta name="twitter:image:alt" content="FALLPHABET - Try to win with as few words as possible!" />
  <link rel="icon" type="image/png" href="/fallphabet-favicon.png">
  <style>
    html {
      background: #ffe5d9;
    }
    body {
      background: #ffe5d9;
      min-height: 100vh;
      min-width: 100vw;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      background: transparent;
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  <div id="main-content">
    <!-- Header Section -->
    <header class="game-header">
      <h1 class="game-title">FALLPHABET</h1>
      <div class="game-stats">
        <div class="stat-item">
          <span class="stat-label" style="font-family: 'Arial', 'Helvetica', sans-serif;">Pts:</span>
          <span id="score-display" class="stat-value">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label chain-label" title="Chain Multiplier">
            <svg class="chain-svg" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" width="22" height="22" style="vertical-align:middle;margin-right:4px;"><rect x="12.7835" y="2.38351" width="6" height="10" rx="3" transform="rotate(33.0385 12.7835 2.38351)" stroke="#000000" stroke-width="2" stroke-linecap="round"></rect> <rect x="7.83558" y="6.32284" width="6" height="10" rx="3" transform="rotate(33.0385 7.83558 6.32284)" stroke="#000000" stroke-width="2" stroke-linecap="round"></rect></svg>
          </span>
          <span id="chain-display" class="stat-value">x1</span>
        </div>
        <!-- Taptile mode specific stats -->
        <div id="taptile-stats" class="taptile-stats" style="display: none;">
          <div class="stat-item">
            <span class="stat-label" style="font-family: 'Arial', 'Helvetica', sans-serif;">Speed:</span>
            <span id="speed-display" class="stat-value">1x</span>
          </div>
          <div class="stat-item">
            <span class="stat-label" style="font-family: 'Arial', 'Helvetica', sans-serif;">
              <svg class="clock-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" width="16" height="16" style="vertical-align:middle;margin-right:2px;">
                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                <path d="M12 6v6l4 2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </span>
            <span id="time-display" class="stat-value">5.0s</span>
          </div>
        </div>
      </div>
    </header>

    <!-- Top Menu Bar -->
    <div id="top-menu" class="top-menu">
      <!-- Mode Selector -->
      <div id="mode-selector" class="mode-selector">
        <button id="daily-mode-btn" class="mode-btn active" data-mode="daily">Daily</button>
        <button id="taptile-mode-btn" class="mode-btn" data-mode="taptile">Taptile</button>
      </div>
      
      <div class="menu-buttons">
        <button id="howto-btn" class="top-menu-btn" title="How to Play">?</button>
        <button id="stats-btn" class="top-menu-btn" title="Your Stats">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#7c3aed" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="12" width="4" height="8"/><rect x="9" y="8" width="4" height="12"/><rect x="15" y="4" width="4" height="16"/></svg>
        </button>
        <button id="leaderboard-btn" class="top-menu-btn" title="Global Leaderboard" style="display: none;">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#7c3aed" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M6 2v10"/><path d="M6 20h1.5a2.5 2.5 0 0 0 0-5H6"/><path d="M6 12v8"/><path d="M14 9h1.5a2.5 2.5 0 0 0 0-5H14"/><path d="M14 2v10"/><path d="M14 20h1.5a2.5 2.5 0 0 1 0-5H14"/><path d="M14 12v8"/><path d="M22 9h-1.5a2.5 2.5 0 0 1 0-5H22"/><path d="M22 2v10"/><path d="M22 20h-1.5a2.5 2.5 0 0 0 0-5H22"/><path d="M22 12v8"/></svg>
        </button>
      </div>
    </div>

    <!-- Playfield Container (only one, centered) -->
    <div id="playfield-container"></div>
  </div>

  <!-- Flash Message Area -->
  <div id="flash-message" class="flash-message"></div>

  <!-- Game Over Modal -->
  <div id="gameover-modal" class="slideup-modal">
    <div class="slideup-modal-content">
      <button id="modal-close-btn" class="slideup-close-btn" aria-label="Close">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
      <h2 class="modal-title">Game Over!</h2>
      <div class="modal-stats">
        <div><strong>Words Used:</strong> <span id="modal-words-used">0</span></div>
        <div><strong>Top Word:</strong> <span id="modal-top-word">-</span></div>
        <div><strong>Highest Chain:</strong> <span id="modal-highest-chain">x1</span></div>
        <!-- Taptile mode specific stats -->
        <div id="taptile-modal-stats" style="display: none;">
          <div><strong>Final Score:</strong> <span id="modal-final-score">0</span></div>
          <div><strong>Max Speed:</strong> <span id="modal-max-speed">1x</span></div>
          <div><strong>Time Survived:</strong> <span id="modal-time-survived">0s</span></div>
        </div>
      </div>
      <div class="modal-actions">
        <button id="modal-share-btn" class="modal-btn primary">Share</button>
        <button id="modal-restart-btn" class="modal-btn" style="display:none;"></button>
      </div>
    </div>
  </div>

  <!-- Slide-up How to Play Modal -->
  <div id="howto-modal" class="slideup-modal">
    <div class="slideup-modal-content">
      <button class="slideup-close-btn" id="howto-close">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
      <h2>How to Play</h2>
      <div class="instructions-text">
        <h3>How to Play</h3>
        <p>• Tap tiles in sequence to build words</p>
        <p>• Double-tap last letter to submit</p>
        <p>• Tap outside grid to reset current word</p>
        <p>• Selection auto-clears after 1.25 seconds</p>
        
        <h3>Scoring & Chains</h3>
        <p>• Letters have point values (like Scrabble)</p>
        <p>• Longer words = more points</p>
        <p>• Start new word within 1.25 seconds to build chain</p>
        <p>• Chain multiplier: 2nd word x2, 3rd word x3, etc.</p>
        <p>• Miss timing = chain resets to x1</p>
        
        <h3 id="goal-title">Goal</h3>
        <div id="daily-goal">
          <p>• Reach 200 points with fewest words possible</p>
          <p>• No time limit - make words as long as possible</p>
        </div>
        <div id="taptile-goal" style="display: none;">
          <h4>Continuous Run Mode</h4>
          <p>• Survive as long as possible with increasing speed</p>
          <p>• Make a new word within the time window or lose</p>
          <p>• Time window shrinks as speed increases</p>
          <p>• Speed increases every 3 words</p>
          <p>• Time window decreases from 5.0s to 1.5s</p>
          <p>• Compete globally on the leaderboard!</p>
          <p>• Your personal best is saved locally</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Slide-up Stats/History Modal -->
  <div id="stats-modal" class="slideup-modal">
    <div class="slideup-modal-content">
      <button class="slideup-close-btn" id="stats-close">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
      <h2>Your Stats</h2>
      <div id="stats-history-content">
        <!-- Stats and history will be rendered here -->
      </div>
    </div>
  </div>

  <!-- Global Leaderboard Modal -->
  <div id="leaderboard-modal" class="slideup-modal">
    <div class="slideup-modal-content">
      <button class="slideup-close-btn" id="leaderboard-close">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
      <h2>Global Leaderboard</h2>
      <div id="leaderboard-content">
        <div class="loading">Loading leaderboard...</div>
      </div>
    </div>
  </div>
  
  <script>
    // Game Mode Manager
    class GameModeManager {
      constructor() {
        // Restore last selected mode from localStorage, default to 'daily'
        const savedMode = localStorage.getItem('fallphabet_selected_mode');
        this.currentMode = savedMode === 'taptile' ? 'taptile' : 'daily';
        this.modes = {
          daily: {
            name: 'Daily Challenge',
            goal: 200,
            timeLimit: null,
            speedIncrease: false,
            leaderboard: false
          },
          taptile: {
            name: 'Fallphabet Taptile',
            goal: null,
            timeLimit: 5.0,
            speedIncrease: true,
            leaderboard: true
          }
        };
      }
      
      setMode(mode) {
        this.currentMode = mode;
        // Save selected mode to localStorage
        localStorage.setItem('fallphabet_selected_mode', mode);
        this.updateUI();
      }
      
      getCurrentMode() {
        return this.modes[this.currentMode];
      }
      
      updateUI() {
        // Update mode buttons
        document.querySelectorAll('.mode-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector(`[data-mode="${this.currentMode}"]`).classList.add('active');
        
        // Update stats display
        const taptileStats = document.getElementById('taptile-stats');
        const leaderboardBtn = document.getElementById('leaderboard-btn');
        const mainContent = document.getElementById('main-content');
        
        if (this.currentMode === 'taptile') {
          taptileStats.style.display = 'flex';
          leaderboardBtn.style.display = 'block';
          mainContent.classList.add('taptile-mode');
        } else {
          taptileStats.style.display = 'none';
          leaderboardBtn.style.display = 'block'; // Show leaderboard for Daily Challenge too
          mainContent.classList.remove('taptile-mode');
        }
        
        // Update instructions
        const dailyGoal = document.getElementById('daily-goal');
        const taptileGoal = document.getElementById('taptile-goal');
        
        if (this.currentMode === 'taptile') {
          dailyGoal.style.display = 'none';
          taptileGoal.style.display = 'block';
        } else {
          dailyGoal.style.display = 'block';
          taptileGoal.style.display = 'none';
        }
      }
    }

    // Taptile Speed Manager
    class TaptileSpeedManager {
      constructor() {
        this.baseSpeed = 150;
        this.currentSpeed = this.baseSpeed;
        this.speedMultiplier = 1.0;
        this.timeWindow = 5.0;
        this.lastWordTime = 0;
        this.speedIncreaseInterval = 30; // Increase speed every 30 seconds
        this.speedIncreaseAmount = 0.2; // 20% increase
        this.timeWindowDecrease = 0.5; // 0.5 second decrease
        this.minTimeWindow = 1.0; // Minimum 1 second
        this.maxSpeedMultiplier = 5.0; // Maximum 5x speed
        this.speedTimer = null;
      }
      
      start() {
        this.currentSpeed = this.baseSpeed;
        this.speedMultiplier = 1.0;
        this.timeWindow = 5.0;
        this.lastWordTime = Date.now(); // Set to current time so first word has full time window
        this.gracePeriod = false; // Initialize grace period
        this.startSpeedTimer();
        this.updateUI();
      }
      
      startSpeedTimer() {
        this.speedTimer = setInterval(() => {
          this.increaseSpeed();
        }, this.speedIncreaseInterval * 1000);
      }
      
      increaseSpeed() {
        this.speedMultiplier = Math.min(this.speedMultiplier + this.speedIncreaseAmount, this.maxSpeedMultiplier);
        this.currentSpeed = Math.max(this.baseSpeed * this.speedMultiplier, this.baseSpeed); // Never below base speed
        this.timeWindow = Math.max(this.timeWindow - this.timeWindowDecrease, this.minTimeWindow);
        this.updateUI();
      }
      
      onWordSubmitted() {
        // Don't reset lastWordTime here - it should be reset when starting a new word
        // Add a small grace period to prevent immediate game over
        this.gracePeriod = true;
        setTimeout(() => {
          this.gracePeriod = false;
        }, 100); // 100ms grace period
      }
      
      onWordStarted() {
        // Reset the timer when player starts working on a new word
        this.lastWordTime = Date.now();
      }
      
      checkTimeWindow() {
        // Always allow time window check since lastWordTime is set on start
        // But respect grace period after word submission
        if (this.gracePeriod) {
          return true;
        }
        const now = Date.now();
        const timeSinceLastWord = (now - this.lastWordTime) / 1000;
        return timeSinceLastWord <= this.timeWindow;
      }
      
      getCurrentSpeed() {
        return this.currentSpeed;
      }
      
      getSpeedMultiplier() {
        return this.speedMultiplier;
      }
      
      getTimeWindow() {
        return this.timeWindow;
      }
      
      updateUI() {
        const speedDisplay = document.getElementById('speed-display');
        const timeDisplay = document.getElementById('time-display');
        if (speedDisplay) {
          speedDisplay.textContent = `${Math.max(this.speedMultiplier, 1.0).toFixed(1)}x`;
        }
        if (timeDisplay) {
          timeDisplay.textContent = `${Math.max(this.timeWindow, 1.0).toFixed(1)}s`;
        }
      }
      
      stop() {
        if (this.speedTimer) {
          clearInterval(this.speedTimer);
          this.speedTimer = null;
        }
        // Show last valid values instead of zero
        const speedDisplay = document.getElementById('speed-display');
        const timeDisplay = document.getElementById('time-display');
        if (speedDisplay) speedDisplay.textContent = `${Math.max(this.speedMultiplier, 1.0).toFixed(1)}x`;
        if (timeDisplay) timeDisplay.textContent = `${Math.max(this.timeWindow, 1.0).toFixed(1)}s`;
      }
      
      getStats() {
        return {
          maxSpeed: this.speedMultiplier,
          timeSurvived: (Date.now() - this.lastWordTime) / 1000
        };
      }
    }



    // TileSpawner Module
    class TileSpawner {
      constructor(scene, gridX, gridY, gridWidth, gridHeight, columns, rows) {
        this.scene = scene;
        this.gridX = gridX;
        this.gridY = gridY;
        this.gridWidth = gridWidth;
        this.gridHeight = gridHeight;
        this.columns = columns;
        this.rows = rows;
        this.tileSize = (this.gridWidth / this.columns) * 0.75; // Smaller tiles for more margin
        this.tileMargin = (this.gridWidth / this.columns - this.tileSize) / 2; // Larger margin
        // Reduce the vertical gap between tiles
        this.tileSpacing = 8; // Reduced from 24 to 8 for tighter vertical spacing
        this.fallSpeed = 150; // pixels/sec, smoother and more playable
        this.letters = {
          'E': 10, 'A': 8, 'I': 7, 'N': 6, 'O': 7, 'R': 6, 'T': 6, 'L': 5, 'S': 5, 'U': 4,
          'D': 4, 'P': 3, 'M': 3, 'H': 3, 'G': 3, 'B': 3, 'F': 3, 'Y': 2, 'W': 2, 'K': 2,
          'V': 2, 'X': 1, 'Z': 1, 'J': 1, 'Q': 1, 'C': 4
        };
        this.letterPool = [];
        this.buildLetterPool();
        // Each column has a queue of falling tiles
        this.columnsTiles = Array.from({length: columns}, () => []);
        this.columnX = [];
        for (let i = 0; i < columns; i++) {
          this.columnX.push(gridX + (i + 0.5) * (gridWidth / columns));
        }
        // Set up per-column spawn timers for natural cascade
        this.columnTimers = [];
        this.baseSpawnInterval = 1000; // ms, base interval for 1x speed
        for (let col = 0; col < this.columns; col++) {
          let isFirstSpawn = true;
          const spawnNext = () => {
            // Only spawn if last tile is far enough down
            const colTiles = this.columnsTiles[col];
            const lastTile = colTiles.length > 0 ? colTiles[colTiles.length - 1] : null;
            const spawnY = this.gridY - this.tileSize / 2;
            let requiredSpacing = this.tileSize + this.tileSpacing;
            if (lastTile && lastTile.y < spawnY + requiredSpacing) {
              // Not enough space, retry soon
              this.columnTimers[col] = this.scene.time.addEvent({
                delay: 100,
                callback: spawnNext,
                callbackScope: this
              });
              return;
            }
            const tile = this.spawnTile(col, spawnY);
            this.columnsTiles[col].push(tile);
            // Schedule the next spawn with dynamic interval based on speed
            let delay;
            if (isFirstSpawn) {
              // Only the first spawn is randomized
              delay = Phaser.Math.Between(900, 1200);
              isFirstSpawn = false;
            } else {
              // Calculate spawn interval based on current fall speed to maintain consistent spacing
              const currentSpeed = this.scene.gameModeManager && this.scene.gameModeManager.getCurrentMode().speedIncrease 
                ? this.scene.taptileSpeedManager.getCurrentSpeed() 
                : this.fallSpeed;
              const speedMultiplier = currentSpeed / 150; // 150 is the base speed
              delay = Math.max(100, this.baseSpawnInterval / speedMultiplier); // Ensure minimum 100ms delay
            }
            this.columnTimers[col] = this.scene.time.addEvent({
              delay: delay,
              callback: spawnNext,
              callbackScope: this
            });
          };
          // Start the first spawn with a unique random initial delay per column
          let initialDelay = Phaser.Math.Between(0, 800);
          if (col === 0) initialDelay += 200; // Delay column 1 by 0.2s
          if (col === 1) initialDelay = Math.max(0, initialDelay - 800); // Column 2 spawns 0.8s earlier
          if (col === 3) initialDelay += 800; // Delay column 4 by 0.8s
          if (col === 4) initialDelay += 1200; // Delay column 5 by 1.2s
          this.scene.time.addEvent({
            delay: initialDelay,
            callback: spawnNext,
            callbackScope: this
          });
        }
      }
      
      buildLetterPool() {
        for (const [letter, freq] of Object.entries(this.letters)) {
          for (let i = 0; i < freq; i++) this.letterPool.push(letter);
        }
      }
      
      getRandomLetter() {
        return this.letterPool[Math.floor(Math.random() * this.letterPool.length)];
      }
      
      spawnTile(col, y) {
        const letter = this.getRandomLetter();
        const x = this.columnX[col];
        // Shadow (subtle, larger, more transparent)
        const shadow = this.scene.add.rectangle(x + 3, y + 6, this.tileSize + 4, this.tileSize + 4, 0xC2A477, 0.18);
        shadow.setDepth(0);
        // Main tile (rounded rectangle)
        const tile = this.scene.add.rectangle(x, y, this.tileSize, this.tileSize, 0xFFF5E1);
        tile.setStrokeStyle(3, 0xB8860B);
        tile.setDepth(1);
        tile.setInteractive();
        tile.isScrabbleTile = true;
        tile.radius = 12;
        // Inner shadow (drawn as a slightly smaller, semi-transparent rectangle)
        const innerShadow = this.scene.add.rectangle(x, y, this.tileSize - 6, this.tileSize - 6, 0x8B6B2F, 0.08);
        innerShadow.setDepth(2);
        // Letter text
        const text = this.scene.add.text(x, y, letter, {
          fontFamily: 'Inter', fontSize: '64px', color: '#222', fontStyle: 'normal', fontWeight: '300',
        }).setOrigin(0.5);
        text.setDepth(3);
        text.setShadow(2, 3, '#B8860B', 2, false, true);
        // Apply the grid mask to all tile elements
        const mask = this.scene.gridMask;
        tile.setMask(mask);
        text.setMask(mask);
        shadow.setMask(mask);
        innerShadow.setMask(mask);
        tile.letter = letter;
        tile.text = text;
        tile.col = col;
        tile.falling = true;
        tile.shadow = shadow;
        tile.innerShadow = innerShadow;
        // Add a subtle spawn animation
        tile.setScale(0.85);
        text.setScale(0.85);
        shadow.setScale(0.85);
        innerShadow.setScale(0.85);
        this.scene.tweens.add({
          targets: [tile, text, shadow, innerShadow],
          scaleX: 1,
          scaleY: 1,
          duration: 300,
          ease: 'Back.easeOut'
        });
        return tile;
      }
      
      update(dt) {
        // Update fall speed based on current mode
        if (this.scene.gameModeManager && this.scene.gameModeManager.getCurrentMode().speedIncrease) {
          this.fallSpeed = this.scene.taptileSpeedManager.getCurrentSpeed();
        }
        
        for (let col = 0; col < this.columns; col++) {
          let colTiles = this.columnsTiles[col];
          for (let i = 0; i < colTiles.length; i++) {
            const tile = colTiles[i];
            if (!tile.falling) continue;
            tile.y += this.fallSpeed * dt;
            tile.text.y = tile.y;
            if (tile.shadow) tile.shadow.y = tile.y + 6;
            if (tile.innerShadow) tile.innerShadow.y = tile.y;
          }
          // Remove tiles with smooth slide-out animation
          for (let i = colTiles.length - 1; i >= 0; i--) {
            const tile = colTiles[i];
            if (tile.y + this.tileSize / 2 >= this.scene.playfieldBottomY) {
              this.scene.tweens.add({
                targets: [tile, tile.text, tile.shadow, tile.innerShadow],
                scaleX: 0.8,
                scaleY: 0.8,
                alpha: 0,
                duration: 200,
                ease: 'Power2',
                onComplete: () => {
                  tile.destroy();
                  tile.text.destroy();
                  if (tile.shadow) tile.shadow.destroy();
                  if (tile.innerShadow) tile.innerShadow.destroy();
                }
              });
              colTiles.splice(i, 1);
            }
          }
        }
      }
      
      getAllTiles() {
        return this.columnsTiles.flat();
      }
      
      clearAllTiles() {
        // Clear all tiles from all columns
        for (let col = 0; col < this.columns; col++) {
          const colTiles = this.columnsTiles[col];
          for (let i = colTiles.length - 1; i >= 0; i--) {
            const tile = colTiles[i];
            if (tile && !tile.destroyed) {
              tile.destroy();
              if (tile.text && !tile.text.destroyed) tile.text.destroy();
              if (tile.shadow && !tile.shadow.destroyed) tile.shadow.destroy();
              if (tile.innerShadow && !tile.innerShadow.destroyed) tile.innerShadow.destroy();
            }
          }
          this.columnsTiles[col] = [];
        }
        
        // Clear all timers
        if (this.columnTimers) {
          this.columnTimers.forEach(timer => {
            if (timer) {
              timer.paused = true;
              timer.remove();
            }
          });
          this.columnTimers = [];
        }
      }
    }

    // InputHandler Module
    class InputHandler {
      constructor(scene, tileSpawner) {
        this.scene = scene;
        this.tileSpawner = tileSpawner;
        this.selectedTiles = [];
        this.buffer = [];
        this.isDragging = false;
        this.lastTile = null;
        this.lastTapTime = 0;
        this.lastTappedTile = null;
        this.autoClearTimeout = null;
        // Set up input events
        this.scene.input.on('pointerdown', this.onPointerDown, this);
        this.scene.input.on('pointermove', this.onPointerMove, this);
        this.scene.input.on('pointerup', this.onPointerUp, this);
        // Also allow tap-to-select
        this.scene.input.on('gameobjectdown', this.onTileTap, this);
      }
      
      onPointerDown(pointer) {
        this.isDragging = true;
        
        // Check if click is outside the grid area
        const x = pointer.x;
        const y = pointer.y;
        const isOutsideGrid = x < this.scene.gridX || 
                             x > this.scene.gridX + this.scene.gridWidth ||
                             y < this.scene.gridY || 
                             y > this.scene.gridY + this.scene.gridHeight;
        
        // If outside grid and we have selected tiles, clear the buffer
        if (isOutsideGrid && this.selectedTiles.length > 0) {
          this.clearBuffer();
          return;
        }
        
        // Only clear buffer if not already selecting
        if (!this.selectedTiles.length) this.clearBuffer();
        this.selectTileAt(pointer.x, pointer.y);
      }
      
      onPointerMove(pointer) {
        if (!this.isDragging) return;
        this.selectTileAt(pointer.x, pointer.y);
      }
      
      onPointerUp(pointer) {
        this.isDragging = false;
        // Do not clear buffer here; let user tap to build words
      }
      
      onTileTap(pointer, tile) {
        if (!tile || !tile.isScrabbleTile) return;
        
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const now = Date.now();
        // Double-tap detection
        if (this.lastTappedTile === tile && (now - this.lastTapTime) < 350) {
          // Only submit if this tile is the last selected tile
          if (this.selectedTiles.length && this.selectedTiles[this.selectedTiles.length - 1] === tile) {
            this.submitWord();
            this.clearAutoClearTimer();
            return;
          }
        } else {
          if (!this.selectedTiles.includes(tile)) {
            this.selectedTiles.push(tile);
            this.buffer.push(tile.letter);
            this.highlightTile(tile, true);
            this.lastTile = tile;
            // If this is the first tile of a new word, handle chain increment and reset taptile timer
            if (this.selectedTiles.length === 1) {
              if (this.scene.chainTracker && this.scene.chainTracker.chainWindowActive) {
                this.scene.chainTracker.shouldIncrementChain = true;
                this.scene.chainTracker.clearChainWindow();
              }
              // Reset the taptile timer when starting a new word
              if (this.scene.taptileSpeedManager) {
                this.scene.taptileSpeedManager.onWordStarted();
              }
            }
          }
        }
        this.lastTappedTile = tile;
        this.lastTapTime = now;
        this.resetAutoClearTimer();
      }
      
      selectTileAt(x, y) {
        const tiles = this.tileSpawner.getAllTiles();
        for (const tile of tiles) {
          if (!tile || tile.destroyed || !tile.isScrabbleTile) continue;
          const distance = Phaser.Math.Distance.Between(x, y, tile.x, tile.y);
          if (distance <= tile.width / 2) {
            if (this.lastTile && tile !== this.lastTile) {
              // Check if this tile is adjacent to the last selected tile
              const lastCol = this.lastTile.col;
              const currentCol = tile.col;
              const lastIndex = this.tileSpawner.columnsTiles[lastCol].indexOf(this.lastTile);
              const currentIndex = this.tileSpawner.columnsTiles[currentCol].indexOf(tile);
              const isAdjacent = (
                (Math.abs(currentCol - lastCol) === 1 && Math.abs(currentIndex - lastIndex) <= 1) ||
                (currentCol === lastCol && Math.abs(currentIndex - lastIndex) === 1)
              );
              if (!isAdjacent) continue;
            }
            if (!this.selectedTiles.includes(tile)) {
              this.selectedTiles.push(tile);
              this.buffer.push(tile.letter);
              this.highlightTile(tile, true);
            }
            this.lastTile = tile;
            break;
          }
        }
      }
      
      highlightTile(tile, highlight) {
        if (!tile || tile.destroyed) return;
        if (highlight) {
          tile.setFillStyle(0x90EE90); // Light green
          tile.setStrokeStyle(3, 0x228B22); // Dark green border
          if (tile.text && !tile.text.destroyed) tile.text.setColor('#006400');
        } else {
          tile.setFillStyle(0xFFF5E1); // Original color
          tile.setStrokeStyle(3, 0xB8860B); // Original border
          if (tile.text && !tile.text.destroyed) tile.text.setColor('#222');
        }
      }
      
      resetAutoClearTimer() {
        this.clearAutoClearTimer();
        this.autoClearTimeout = setTimeout(() => {
          this.clearBuffer();
        }, 1250); // 1.25 seconds
      }

      clearAutoClearTimer() {
        if (this.autoClearTimeout) {
          clearTimeout(this.autoClearTimeout);
          this.autoClearTimeout = null;
        }
      }

      clearBuffer(skipDestruction = false) {
        this.selectedTiles.forEach((tile, index) => {
          // Only destroy tiles when clearing buffer for unsuccessful selections
          if (!skipDestruction && tile && !tile.destroyed) {
            tile.destroy();
            if (tile.text && !tile.text.destroyed) tile.text.destroy();
            if (tile.shadow && !tile.shadow.destroyed) tile.shadow.destroy();
            if (tile.innerShadow && !tile.innerShadow.destroyed) tile.innerShadow.destroy();
          }
        });
        this.selectedTiles = [];
        this.buffer = [];
        this.lastTile = null;
        this.clearAutoClearTimer();
      }
      
      submitWord() {
        if (this.buffer.length < 2) return;
        const word = this.buffer.join('');
        const tiles = [...this.selectedTiles];
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Clear buffer immediately to prevent word combination
        this.clearBuffer(true);
        
        this.scene.events.emit('wordSubmitted', {
          word: word,
          tiles: tiles
        });
      }
      
      update() {
        // Any per-frame updates if needed
      }
    }

    // ScoreManager Module
    class ScoreManager {
      constructor() {
        this.totalScore = 0;
        this.letterScores = {
          'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1, 'F': 4, 'G': 2, 'H': 4, 'I': 1, 'J': 8,
          'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1, 'P': 3, 'Q': 10, 'R': 1, 'S': 1, 'T': 1,
          'U': 1, 'V': 4, 'W': 4, 'X': 8, 'Y': 4, 'Z': 10
        };
      }
      
      calculateScore(word, chainMultiplier = 1) {
        let score = 0;
        for (const letter of word.toUpperCase()) {
          score += this.letterScores[letter] || 0;
        }
        return score * chainMultiplier;
      }
      
      addScore(points) {
        this.totalScore += points;
      }
      
      getTotalScore() {
        return this.totalScore;
      }
      
      reset() {
        this.totalScore = 0;
      }
    }

    // ChainTracker Module
    class ChainTracker {
      constructor() {
        this.chainLevel = 1;
        this.highestChain = 1;
        this.lastWordTime = 0;
        this.chainWindowDuration = 1250; // 1.25 seconds
        this.chainWindowTimeout = null;
        this.chainWindowActive = false;
        this.shouldIncrementChain = false;
      }
      
      startChainWindow() {
        this.clearChainWindow();
        this.chainWindowActive = true;
        this.shouldIncrementChain = false;
        this.chainWindowTimeout = setTimeout(() => {
          this.resetChain();
          this.chainWindowActive = false;
          this.shouldIncrementChain = false;
          if (window && window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
            const scene = window.game.scene.keys['GameScene'];
            if (scene.updateUI) scene.updateUI();
          }
        }, this.chainWindowDuration);
      }
      
      clearChainWindow() {
        if (this.chainWindowTimeout) {
          clearTimeout(this.chainWindowTimeout);
          this.chainWindowTimeout = null;
        }
        this.chainWindowActive = false;
      }
      
      incrementOnNextWord() {
        this.chainLevel++;
        if (this.chainLevel > this.highestChain) this.highestChain = this.chainLevel;
        this.clearChainWindow();
      }
      
      resetChain() {
        this.chainLevel = 1;
        this.clearChainWindow();
        if (window && window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
          const scene = window.game.scene.keys['GameScene'];
          if (scene.updateUI) scene.updateUI();
        }
      }
      
      getChainLevel() {
        return this.chainLevel;
      }
      getHighestChain() {
        return this.highestChain;
      }
    }

    // GameScene
    class GameScene extends Phaser.Scene {
      constructor() {
        super({ key: 'GameScene' });
        // Reset all game state for the new mode
        this.scoreManager = new ScoreManager();
        this.chainTracker = new ChainTracker();
        this.inputHandler = null;
        this.tileSpawner = null;
        this.taptileSpeedManager = null;
        this.leaderboardManager = null;
        this.wordsUsed = 0;
        this.topWord = '';
        this.topWordScore = 0;
        this.highestChain = 1;
        this.gameOver = false;
        this.gameStartTime = Date.now();
        this.scoredWords = [];
      }
      
      create() {
        // Get playfield dimensions
        const playfieldWidth = 800;
        const playfieldHeight = 1200;
        
        // Grid setup
        this.gridX = 50;
        this.gridY = 50;
        this.gridWidth = playfieldWidth - 100;
        this.gridHeight = playfieldHeight - 100;
        this.playfieldBottomY = this.gridY + this.gridHeight;
        
        // Change columns to 5 for a 5-column grid
        this.columns = 5;
        this.rows = 12;
        
        // Recalculate tile size and margin for 5 columns, keeping the same margin formula
        this.tileSize = (this.gridWidth / this.columns) * 0.75; // Keep the same 75% sizing
        this.tileMargin = (this.gridWidth / this.columns - this.tileSize) / 2;
        // Recalculate column positions for 5 columns
        this.columnX = [];
        for (let i = 0; i < this.columns; i++) {
          this.columnX.push(this.gridX + (i + 0.5) * (this.gridWidth / this.columns));
        }
        
        console.log('Creating GameScene...');
        
        // Create grid outline
        this.grid = this.add.rectangle(
          this.gridX + this.gridWidth / 2,
          this.gridY + this.gridHeight / 2,
          this.gridWidth,
          this.gridHeight,
          0xFFFFFF,
          0
        );
        this.grid.setStrokeStyle(3, 0x000000);
        
        // Create a geometry mask for the playfield
        const maskShape = this.add.graphics();
        maskShape.fillStyle(0xffffff);
        maskShape.fillRect(this.gridX, this.gridY, this.gridWidth, this.gridHeight);
        this.gridMask = maskShape.createGeometryMask();
        
        // Add column dividers for better visual separation
        for (let i = 1; i < this.columns; i++) {
          const dividerX = this.gridX + (i * this.gridWidth / this.columns);
          this.add.line(dividerX, this.gridY, dividerX, this.gridY + this.gridHeight, 0x8B4513, 2);
        }
        
        // Initialize modules
        console.log('Initializing modules...');
        this.tileSpawner = new TileSpawner(this, this.gridX, this.gridY, this.gridWidth, this.gridHeight, this.columns, this.rows);
        
        this.inputHandler = new InputHandler(this, this.tileSpawner);
        this.scoreManager = new ScoreManager();
        this.chainTracker = new ChainTracker();
        
        // Initialize mode managers
        this.gameModeManager = window.gameModeManager || new GameModeManager();
        this.taptileSpeedManager = new TaptileSpeedManager();
        this.leaderboardManager = new GlobalLeaderboardManager();
        console.log('GameScene: Leaderboard manager initialized:', this.leaderboardManager);
        
        // Game state
        this.wordsUsed = 0;
        this.topWord = '';
        this.topWordScore = 0;
        this.highestChain = 1;
        this.gameOver = false;
        this.gameStartTime = Date.now();
        
        // Start taptile mode if active
        if (this.gameModeManager.getCurrentMode().speedIncrease) {
          this.taptileSpeedManager.start();
        }
        
        // Listen for word submissions
        this.events.on('wordSubmitted', this.handleWordSubmission, this);
        
        console.log('GameScene create completed');

        // Add bottom border line
        this.add.line(
          this.gridX,
          this.gridY + this.gridHeight,
          this.gridX + this.gridWidth,
          this.gridY + this.gridHeight,
          0x000000,
          1
        ).setOrigin(0, 0).setLineWidth(3).setDepth(100);

        // In GameScene create() or init(), reset the score and chain display
        const scoreDisplay = document.getElementById('score-display');
        if (scoreDisplay) scoreDisplay.textContent = '0';
        const chainDisplay = document.getElementById('chain-display');
        if (chainDisplay) chainDisplay.textContent = 'x1';

        // In GameScene create() or init(), clear any word buffer and selected tiles
        if (this.inputHandler) {
          this.inputHandler.clearBuffer();
        }
      }

      update(time, delta) {
        if (this.gameOver) return;
        const dt = delta / 1000;
        this.tileSpawner.update(dt);
        this.inputHandler.update();
        
        // Check taptile time window
        if (this.gameModeManager && this.gameModeManager.getCurrentMode().speedIncrease) {
          if (!this.taptileSpeedManager.checkTimeWindow() && this.wordsUsed > 0) {
            this.endGame();
            return;
          }
        }
        
        this.updateUI();
      }
      
      async handleWordSubmission(data) {
        if (this.gameOver) return;
        const { word, tiles } = data;
        // Always clean up tiles from spawner tracking, regardless of validation result
        tiles.forEach(tile => {
          if (tile && tile.col !== undefined && this.tileSpawner.columnsTiles[tile.col]) {
            const colIndex = this.tileSpawner.columnsTiles[tile.col].indexOf(tile);
            if (colIndex > -1) {
              this.tileSpawner.columnsTiles[tile.col].splice(colIndex, 1);
            }
          }
        });
        // Strict English word validation
        let isValid = false;
        let isProper = false;
        let apiFailed = false;
        
        try {
          const controller = new AbortController();
          // Longer timeout for mobile devices
          const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
          const timeout = isMobile ? 10000 : 5000; // 10 seconds on mobile, 5 on desktop
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word.toLowerCase()}`, {
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          
          if (res.ok) {
            const data = await res.json();
            if (Array.isArray(data)) {
              // Check all meanings for proper noun
              isProper = data.some(entry =>
                entry.meanings && entry.meanings.some(meaning =>
                  meaning.partOfSpeech && meaning.partOfSpeech.toLowerCase().includes('proper')
                )
              );
              isValid = true;
            }
          }
        } catch (e) {
          apiFailed = true;
        }
        
        // No fallback - only use the free dictionary API
        if (apiFailed) {
          isValid = false;
        }
        if (!isValid) {
          this.showFlashMessage(`"${word}" - Not a valid English word!`, '#ff6b6b');
          // Destroy tiles for invalid words (buffer already cleared)
          tiles.forEach(tile => {
            if (tile && !tile.destroyed) {
              tile.destroy();
              if (tile.text && !tile.text.destroyed) tile.text.destroy();
              if (tile.shadow && !tile.shadow.destroyed) tile.shadow.destroy();
              if (tile.innerShadow && !tile.innerShadow.destroyed) tile.innerShadow.destroy();
            }
          });
          return;
        }
        if (isProper) {
          this.showFlashMessage(`"${word}" is a proper name. No proper names allowed!`, '#ff6b6b');
          // Destroy tiles for invalid words (buffer already cleared)
          tiles.forEach(tile => {
            if (tile && !tile.destroyed) {
              tile.destroy();
              if (tile.text && !tile.text.destroyed) tile.text.destroy();
              if (tile.shadow && !tile.shadow.destroyed) tile.shadow.destroy();
              if (tile.innerShadow && !tile.innerShadow.destroyed) tile.innerShadow.destroy();
            }
          });
          return;
        }
        
        // If valid and not a proper noun, continue with scoring and animation
        const chainLevel = this.chainTracker.getChainLevel();
        const score = this.scoreManager.calculateScore(word, chainLevel);
        this.scoreManager.addScore(score);
        this.wordsUsed++;
        if (score > this.topWordScore) {
          this.topWordScore = score;
          this.topWord = word;
        }
        this.chainTracker.incrementOnNextWord();
        const chainText = chainLevel > 1 ? ` (x${chainLevel} chain!)` : '';
        this.showFlashMessage(`"${word}" - ${score} pts${chainText}`, '#51cf66');
        this.scoredWords.push({ word, score });
        tiles.forEach(tile => {
          this.tweens.add({
            targets: [tile, tile.text, tile.shadow, tile.innerShadow],
            scaleX: 0,
            scaleY: 0,
            duration: 300,
            ease: 'Power2',
            onComplete: () => {
              tile.destroy();
              if (tile.text) tile.text.destroy();
              if (tile.shadow) tile.shadow.destroy();
              if (tile.innerShadow) tile.innerShadow.destroy();
            }
          });
        });
        // Check for game over based on mode
        const currentMode = this.gameModeManager.getCurrentMode();
        if (currentMode.goal && this.scoreManager.getTotalScore() >= currentMode.goal) {
          this.endGame();
        }
        
        // Update taptile speed manager
        if (currentMode.speedIncrease) {
          this.taptileSpeedManager.onWordSubmitted();
        }
        
        // Always start chain window after word submission
        this.chainTracker.startChainWindow();
      }
      
      showFlashMessage(message, color = '#fff') {
        const flashElement = document.getElementById('flash-message');
        flashElement.textContent = message;
        flashElement.style.color = color;
        flashElement.style.display = 'block';
        
        setTimeout(() => {
          flashElement.style.display = 'none';
        }, 2000);
      }
      
      updateUI() {
        // Update HTML elements instead of Phaser text
        const scoreDisplay = document.getElementById('score-display');
        const chainDisplay = document.getElementById('chain-display');
        
        const currentScore = this.scoreManager.getTotalScore();
        const currentChain = this.chainTracker.getChainLevel();
        
        scoreDisplay.textContent = currentScore;
        scoreDisplay.style.fontFamily = 'Arial, Helvetica, sans-serif';
        
        chainDisplay.textContent = `x${currentChain}`;
        chainDisplay.style.fontFamily = 'Arial, Helvetica, sans-serif';
        
        // Check for game over based on mode (only for Daily Challenge)
        const currentMode = this.gameModeManager.getCurrentMode();
        if (!currentMode.speedIncrease && this.scoreManager.getTotalScore() >= 200 && !this.gameOver) {
          this.endGame();
        }

        // Add a container for the word list
        const modalStats = document.querySelector('.modal-stats');
        let wordListDiv = document.getElementById('modal-word-list');
        if (!wordListDiv) {
          wordListDiv = document.createElement('div');
          wordListDiv.id = 'modal-word-list';
          wordListDiv.style.maxHeight = '160px';
          wordListDiv.style.overflowY = 'auto';
          wordListDiv.style.margin = '18px 0 0 0';
          wordListDiv.style.textAlign = 'left';
          wordListDiv.style.fontSize = '1.05rem';
          wordListDiv.style.lineHeight = '1.4';
          wordListDiv.style.background = '#fff9ef';
          wordListDiv.style.border = '1px solid #e5c9a8';
          wordListDiv.style.borderRadius = '8px';
          wordListDiv.style.padding = '10px 12px';
          modalStats.parentNode.insertBefore(wordListDiv, modalStats.nextSibling);
        }
        // Populate the list on win
        if (this.scoredWords && this.scoredWords.length) {
          wordListDiv.innerHTML = '<strong>Words you scored:</strong><ul style="margin:8px 0 0 0;padding:0;list-style:none;">' +
            this.scoredWords.map(w => `<li style='display:flex;justify-content:space-between;'><span>${w.word}</span><span style='color:#7c3aed;font-weight:bold;'>${w.score} pts</span></li>`).join('') +
            '</ul>';
        } else {
          wordListDiv.innerHTML = '';
        }
      }
      
      // Check if the current score is a new high score for Taptile
      checkTaptileHighScore(currentScore) {
        const playerIdentifier = this.leaderboardManager ? this.leaderboardManager.getPlayerIdentifier() : null;
        if (!playerIdentifier) return true; // If no player ID, treat as new high score
        
        const highScoreKey = `taptile_high_score_${playerIdentifier}`;
        const currentHighScore = parseInt(localStorage.getItem(highScoreKey) || '0');
        
        return currentScore > currentHighScore;
      }
      
      // Update the player's high score for Taptile
      updateTaptileHighScore(score) {
        const playerIdentifier = this.leaderboardManager ? this.leaderboardManager.getPlayerIdentifier() : null;
        if (!playerIdentifier) return;
        
        const highScoreKey = `taptile_high_score_${playerIdentifier}`;
        localStorage.setItem(highScoreKey, score.toString());
      }
      
      // Show confetti animation
      showConfetti() {
        // Create confetti container
        const confettiContainer = document.createElement('div');
        confettiContainer.id = 'confetti-container';
        confettiContainer.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 9999;
        `;
        document.body.appendChild(confettiContainer);
        
        // Create confetti pieces
        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'];
        const confettiCount = 150;
        
        for (let i = 0; i < confettiCount; i++) {
          const confetti = document.createElement('div');
          confetti.style.cssText = `
            position: absolute;
            width: 10px;
            height: 10px;
            background: ${colors[Math.floor(Math.random() * colors.length)]};
            left: ${Math.random() * 100}%;
            top: -10px;
            animation: confetti-fall ${2 + Math.random() * 3}s linear forwards;
            transform: rotate(${Math.random() * 360}deg);
          `;
          confettiContainer.appendChild(confetti);
        }
        
        // Remove confetti after animation
        setTimeout(() => {
          if (confettiContainer.parentNode) {
            confettiContainer.parentNode.removeChild(confettiContainer);
          }
        }, 5000);
      }
      
      // Show high score celebration modal
      showHighScoreModal(score, timeSurvived, maxSpeed, wordsUsed, topWord, topWordScore, highestChain) {
        // Update the high score
        this.updateTaptileHighScore(score);
        
        const modal = document.createElement('div');
        modal.className = 'high-score-modal';
        modal.innerHTML = `
          <div class="high-score-content">
            <div class="high-score-header">
              <h2>🎉 New High Score! 🎉</h2>
              <div class="score-display">${score.toLocaleString()}</div>
            </div>
            <div class="high-score-stats">
              <div class="stat-row">
                <span class="stat-label">Time Survived:</span>
                <span class="stat-value">${timeSurvived.toFixed(1)}s</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Max Speed:</span>
                <span class="stat-value">${maxSpeed.toFixed(1)}x</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Words Used:</span>
                <span class="stat-value">${wordsUsed}</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Top Word:</span>
                <span class="stat-value">"${topWord}" (${topWordScore} pts)</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Highest Chain:</span>
                <span class="stat-value">x${highestChain}</span>
              </div>
            </div>
            <div class="high-score-actions">
              <button id="view-rankings-btn" class="modal-btn primary">View Your Rankings</button>
              <button id="close-high-score-btn" class="modal-btn">Continue</button>
            </div>
          </div>
        `;
        
        document.body.appendChild(modal);
        
        // Event listeners
        const viewRankingsBtn = modal.querySelector('#view-rankings-btn');
        const closeBtn = modal.querySelector('#close-high-score-btn');
        
        viewRankingsBtn.addEventListener('click', () => {
          if (modal.parentNode) {
            modal.parentNode.removeChild(modal);
          }
          // Show global leaderboard
          if (this.leaderboardManager) {
            this.leaderboardManager.showLeaderboardModal('fallphabet_taptile');
          }
        });
        
        closeBtn.addEventListener('click', () => {
          if (modal.parentNode) {
            modal.parentNode.removeChild(modal);
          }
        });
      }

      endGame() {
        this.gameOver = true;
        this.disableInput();
        
        // Stop taptile speed manager
        if (this.taptileSpeedManager) {
          this.taptileSpeedManager.stop();
        }
        
        // Stop all timers in tileSpawner
        if (this.tileSpawner && this.tileSpawner.columnTimers) {
          this.tileSpawner.columnTimers.forEach(timer => { if (timer) timer.paused = true; });
        }
        
        const modal = document.getElementById('gameover-modal');
        const title = modal.querySelector('.modal-title');
        const stats = modal.querySelector('.modal-stats');
        const taptileStats = document.getElementById('taptile-modal-stats');
        const wordsUsed = this.wordsUsed;
        const topWord = this.topWord || '-';
        const topWordScore = this.topWordScore || 0;
        const highestChain = this.chainTracker && this.chainTracker.getHighestChain ? 'x' + this.chainTracker.getHighestChain() : '';
        const finalScore = this.scoreManager.getTotalScore();
        
        const currentMode = this.gameModeManager.getCurrentMode();
        
        if (currentMode.speedIncrease) {
          // Taptile mode
          const taptileStats = this.taptileSpeedManager.getStats();
          const timeSurvived = (Date.now() - this.gameStartTime) / 1000;
          
          if (title) title.textContent = 'Game Over!';
          if (stats) {
            stats.innerHTML = `<div><strong>Words Used:</strong> <span id="modal-words-used">${wordsUsed}</span></div><div><strong>Top Word:</strong> <span id="modal-top-word">${topWord}</span></div><div><strong>Highest Chain:</strong> <span id="modal-highest-chain">x${highestChain}</span></div>`;
          }
          
          // Show taptile specific stats
          const taptileModalStats = document.getElementById('taptile-modal-stats');
          if (taptileModalStats) {
            taptileModalStats.style.display = 'block';
            document.getElementById('modal-final-score').textContent = finalScore;
            document.getElementById('modal-max-speed').textContent = `${taptileStats.maxSpeed.toFixed(1)}x`;
            document.getElementById('modal-time-survived').textContent = `${timeSurvived.toFixed(1)}s`;
          }
          
          // Check if this is a new high score for Taptile
          const isNewHighScore = this.checkTaptileHighScore(finalScore);
          
          if (isNewHighScore) {
            // Show confetti and high score modal
            this.showConfetti();
            this.showHighScoreModal(finalScore, timeSurvived, taptileStats.maxSpeed, wordsUsed, topWord, topWordScore, highestChain);
          }
          
          // Only submit to leaderboard if it's a new high score
          if (isNewHighScore && this.leaderboardManager) {
            const scoreData = {
              score: finalScore,
              gameMode: 'fallphabet_taptile',
              wordsUsed: wordsUsed,
              gameDurationSeconds: timeSurvived,
              maxChainMultiplier: taptileStats.maxSpeed
            };
            
            // Check if player name exists, if not show name input modal
            const playerName = this.leaderboardManager.getPlayerName();
            if (playerName) {
              // Player name exists, submit directly
              this.leaderboardManager.submitScore({
                playerName: playerName,
                ...scoreData
              }).then(result => {
                console.log('Taptile high score submission result:', result);
              });
            } else {
              // No player name, show name input modal
              this.leaderboardManager.showNameInputModal(scoreData, (result, submissionData) => {
                console.log('Taptile high score name input result:', result);
              });
            }
          }
          
          // Save Taptile game stats to localStorage
          saveTaptileGameHistory({
            score: finalScore,
            timeSurvived: timeSurvived,
            maxSpeed: taptileStats.maxSpeed,
            wordsUsed: wordsUsed,
            topWord: topWord,
            topWordScore: topWordScore,
            highestChain: highestChain,
            timestamp: Date.now()
          });
          
          // Always show restart for taptile mode
          const restartBtn = document.getElementById('modal-restart-btn');
          if (restartBtn) {
            restartBtn.textContent = 'Try Again';
            restartBtn.style.display = '';
          }
          
        } else {
          // Daily challenge mode
          if (finalScore >= 200) {
            // Win condition
            if (title) title.textContent = 'You Did It!';
            if (stats) stats.innerHTML = `<span style="font-family: Arial, Helvetica, sans-serif; font-size: 1.2rem; color: #222; display: block;">It took you <strong>${wordsUsed}</strong> words to hit 200 points today.<br><br>Your Top Word was <strong>${topWord}</strong> earning you <strong>${topWordScore}</strong> points.<br><br>You chained <strong>${highestChain}</strong> words together today!<br><br>Come back tomorrow to see if you can beat your score.<br><br>Share with friends to see who can beat the Fallphabet with the fewest words.</span>`;
          } else {
            // Normal game over
            if (title) title.textContent = 'Game Over!';
            if (stats) {
              stats.innerHTML = `<div><strong>Words Used:</strong> <span id="modal-words-used">${wordsUsed}</span></div><div><strong>Top Word:</strong> <span id="modal-top-word">${topWord}</span></div><div><strong>Highest Chain:</strong> <span id="modal-highest-chain">x${highestChain}</span></div>`;
            }
          }
          
          // Hide taptile stats
          const taptileModalStats = document.getElementById('taptile-modal-stats');
          if (taptileModalStats) {
            taptileModalStats.style.display = 'none';
          }
          
          // Submit to Daily Challenge leaderboard
          console.log('Daily Challenge: About to submit to leaderboard');
          console.log('Daily Challenge: Leaderboard manager:', this.leaderboardManager);
          if (this.leaderboardManager) {
            console.log('Daily Challenge: Leaderboard manager available');
            const scoreData = {
              score: finalScore,
              gameMode: 'daily_challenge',
              wordsUsed: wordsUsed,
              topWord: topWord,
              topWordScore: topWordScore,
              maxChainMultiplier: this.chainTracker ? this.chainTracker.getHighestChain() : 1
            };
            
            // Check if player name exists, if not show name input modal
            const playerName = this.leaderboardManager.getPlayerName();
            console.log('Daily Challenge: Player name check:', playerName ? 'exists' : 'missing');
            
            if (playerName) {
              // Player name exists, submit directly
              console.log('Daily Challenge: Submitting with existing name:', playerName);
              this.leaderboardManager.submitScore({
                playerName: playerName,
                ...scoreData
              }).then(result => {
                console.log('Daily Challenge: Submission result:', result);
                if (result.success) {
                  // Show rank in modal
                  const rankText = result.rank ? `You ranked #${result.rank} out of ${result.totalParticipants} players today!` : '';
                  if (rankText) {
                    const statsDiv = document.querySelector('.modal-stats');
                    if (statsDiv) {
                      statsDiv.innerHTML += `<div style="margin-top: 15px; color: #7c3aed; font-weight: bold;">${rankText}</div>`;
                    }
                  }
                  
                  // For successful submissions, hide restart button (one attempt per day)
                  const restartBtn = document.getElementById('modal-restart-btn');
                  if (restartBtn) {
                    restartBtn.style.display = 'none';
                  }
                  
                } else if (result.error && result.error.includes('already completed')) {
                  // Player has already attempted today
                  const statsDiv = document.querySelector('.modal-stats');
                  if (statsDiv) {
                    statsDiv.innerHTML += `<div style="margin-top: 15px; color: #dc3545; font-weight: bold;">${result.error}</div>`;
                  }
                  
                  // Hide restart button for already completed attempts
                  const restartBtn = document.getElementById('modal-restart-btn');
                  if (restartBtn) {
                    restartBtn.style.display = 'none';
                  }
                  
                } else {
                  // For other errors, allow retry
                  const restartBtn = document.getElementById('modal-restart-btn');
                  if (restartBtn) {
                    restartBtn.textContent = 'Try Again';
                    restartBtn.style.display = '';
                  }
                }
              });
            } else {
              // No player name, show name input modal
              console.log('Daily Challenge: Showing name input modal');
              this.leaderboardManager.showNameInputModal(scoreData, (result, submissionData) => {
                console.log('Daily Challenge: Name input result:', result);
                if (result.success) {
                  // Show rank in modal
                  const rankText = result.rank ? `You ranked #${result.rank} out of ${result.totalParticipants} players today!` : '';
                  if (rankText) {
                    const statsDiv = document.querySelector('.modal-stats');
                    if (statsDiv) {
                      statsDiv.innerHTML += `<div style="margin-top: 15px; color: #7c3aed; font-weight: bold;">${rankText}</div>`;
                    }
                  }
                  
                  // For successful submissions, hide restart button (one attempt per day)
                  const restartBtn = document.getElementById('modal-restart-btn');
                  if (restartBtn) {
                    restartBtn.style.display = 'none';
                  }
                  
                } else if (result.error && result.error.includes('already completed')) {
                  // Player has already attempted today
                  const statsDiv = document.querySelector('.modal-stats');
                  if (statsDiv) {
                    statsDiv.innerHTML += `<div style="margin-top: 15px; color: #dc3545; font-weight: bold;">${result.error}</div>`;
                  }
                  
                  // Hide restart button for already completed attempts
                  const restartBtn = document.getElementById('modal-restart-btn');
                  if (restartBtn) {
                    restartBtn.style.display = 'none';
                  }
                  
                } else if (!result.cancelled) {
                  // For other errors, allow retry
                  const restartBtn = document.getElementById('modal-restart-btn');
                  if (restartBtn) {
                    restartBtn.textContent = 'Try Again';
                    restartBtn.style.display = '';
                  }
                }
              });
            }
          } else {
            console.log('Daily Challenge: No leaderboard manager available');
            // Fallback for when leaderboard manager is not available
            const restartBtn = document.getElementById('modal-restart-btn');
            // Hide restart button for Daily Challenge mode (one attempt per day)
            if (restartBtn) {
              restartBtn.style.display = 'none';
            }
          }
          
          // Save game stats to localStorage
          const today = new Date().toLocaleDateString();
          saveGameToHistory({ date: today, wordsUsed, topWord, topWordScore, highestChain, score: finalScore, longestWord: this.topWord });
        }
        
        // Ensure modal is visible and properly positioned
        modal.style.display = 'flex';
        modal.style.zIndex = '3000';
        modal.classList.add('show');
        
        // Hide restart button for Daily Challenge mode (one attempt per day)
        const restartBtn = document.getElementById('modal-restart-btn');
        if (restartBtn && !currentMode.speedIncrease) {
          // Daily Challenge mode - remove restart button completely
          restartBtn.parentNode.removeChild(restartBtn);
        } else if (restartBtn && currentMode.speedIncrease) {
          // Taptile mode - show restart button
          restartBtn.style.display = '';
          restartBtn.style.visibility = 'visible';
          restartBtn.textContent = 'Try Again';
        }
        
        // Also ensure the close button is properly set up
        const closeBtn = document.getElementById('modal-close-btn');
        if (closeBtn) {
          closeBtn.onclick = () => {
            modal.classList.remove('show');
            setTimeout(() => {
              modal.style.display = 'none';
            }, 300);
          };
        }
      }
      disableInput() {
        if (this.inputHandler) {
          // Remove all input event listeners
          if (this.inputHandler.scene && this.inputHandler.scene.input) {
            this.inputHandler.scene.input.off('pointerdown', this.inputHandler.onPointerDown, this.inputHandler);
            this.inputHandler.scene.input.off('pointermove', this.inputHandler.onPointerMove, this.inputHandler);
            this.inputHandler.scene.input.off('pointerup', this.inputHandler.onPointerUp, this.inputHandler);
            this.inputHandler.scene.input.off('gameobjectdown', this.inputHandler.onTileTap, this.inputHandler);
          }
        }
      }
    }

    // Game Configuration
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 1200,
      backgroundColor: '#ffe5d9',
      parent: 'playfield-container',
      scene: [GameScene],
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 }, // Disable gravity, we'll control velocity manually
          debug: false,
        },
      },
    };

    // Start the game
    window.addEventListener('DOMContentLoaded', async () => {
      console.log('DOM loaded, checking Daily Challenge status first...');
      
      // Initialize global game mode manager
      window.gameModeManager = new GameModeManager();
      
      // Ensure leaderboard is initialized before checking Daily Challenge
      if (!window.globalLeaderboard) {
        console.log('Initializing global leaderboard...');
        window.globalLeaderboard = new GlobalLeaderboardManager();
      }
      
      // Wait for Supabase connection to be established
      console.log('Waiting for Supabase connection...');
      let connectionAttempts = 0;
      const maxAttempts = 10;
      
      while (!window.globalLeaderboard.isConnected && connectionAttempts < maxAttempts) {
        console.log(`Connection attempt ${connectionAttempts + 1}/${maxAttempts}`);
        await new Promise(resolve => setTimeout(resolve, 500));
        connectionAttempts++;
      }
      
      if (!window.globalLeaderboard.isConnected) {
        console.log('⚠️ Supabase connection failed after multiple attempts, allowing game creation');
        return true; // Create game anyway
      }
      
      console.log('✅ Supabase connection established, proceeding with Daily Challenge check');
      
      // Check Daily Challenge status immediately (like Wordle)
      const checkDailyChallengeStatus = async () => {
        console.log('=== DAILY CHALLENGE STATUS CHECK START ===');
        
        const currentMode = window.gameModeManager.getCurrentMode();
        console.log('Current mode:', currentMode);
        console.log('Speed increase:', currentMode.speedIncrease);
        
        if (!currentMode.speedIncrease) { // Daily Challenge mode
          console.log('✅ Page loaded in Daily Challenge mode, checking if already attempted today...');
          
          // Wait a bit for leaderboard to initialize
          await new Promise(resolve => setTimeout(resolve, 500));
          
          const playerIdentifier = window.globalLeaderboard ? window.globalLeaderboard.getPlayerIdentifier() : null;
          console.log('Player identifier on page load:', playerIdentifier);
          console.log('Global leaderboard available:', !!window.globalLeaderboard);
          
          if (playerIdentifier && window.globalLeaderboard) {
            console.log('🔍 Checking daily attempt on page load for player:', playerIdentifier);
            
            // Wait for Supabase connection to be established
            let connectionAttempts = 0;
            const maxAttempts = 50; // 5 seconds max wait
            
            while (!window.globalLeaderboard.isConnected && connectionAttempts < maxAttempts) {
              console.log(`⏳ Waiting for Supabase connection... (attempt ${connectionAttempts + 1}/${maxAttempts})`);
              await new Promise(resolve => setTimeout(resolve, 100));
              connectionAttempts++;
            }
            
            if (!window.globalLeaderboard.isConnected) {
              console.log('⚠️ Supabase connection not established after waiting, allowing game creation');
            } else {
              console.log('✅ Supabase connection established, proceeding with daily attempt check');
            }
            
            try {
              const attemptCheck = await window.globalLeaderboard.hasDailyAttemptToday(playerIdentifier);
              console.log('📊 Daily attempt check on page load result:', attemptCheck);
              
              if (attemptCheck.success && attemptCheck.hasAttempted) {
                console.log('🚫 Player has already attempted today on page load, showing modal');
                // Player has already attempted today, show modal immediately
                const todaysScore = await window.globalLeaderboard.getTodaysDailyScore(playerIdentifier);
                window.globalLeaderboard.showDailyAlreadyAttemptedModal(todaysScore.success ? todaysScore.data : null);
                
                // Don't create the game - player has already attempted today
                console.log('❌ Blocking game creation - player already attempted today');
                return false; // Don't create game
              } else {
                console.log('✅ Player has not attempted today on page load, allowing game creation');
              }
            } catch (error) {
              console.error('❌ Error checking daily attempt:', error);
              console.log('⚠️ Allowing game creation due to error');
            }
          } else {
            console.log('⚠️ No player identifier or leaderboard not available on page load, allowing game creation');
            console.log('Player identifier:', playerIdentifier);
            console.log('Leaderboard available:', !!window.globalLeaderboard);
          }
        } else {
          console.log('✅ Not in Daily Challenge mode, allowing game creation');
        }
        
        console.log('=== DAILY CHALLENGE STATUS CHECK END ===');
        return true; // Create game
      };
      
      // Check Daily Challenge status first
      const shouldCreateGame = await checkDailyChallengeStatus();
      
      if (!shouldCreateGame) {
        console.log('Game creation blocked due to Daily Challenge already attempted');
        return; // Don't create the game
      }
      
      console.log('Creating Phaser game...');
      
      // Global function to switch to Taptile mode (used by modals)
      window.switchToTaptileMode = () => {
        console.log('Switching to Taptile mode from modal');
        window.gameModeManager.setMode('taptile');
        // Force UI update after a small delay to ensure DOM is ready
        setTimeout(() => {
          window.gameModeManager.updateUI();
        }, 100);
        
        // Create game if it doesn't exist (in case it was blocked by daily challenge check)
        if (!window.game) {
          console.log('Creating game for Taptile mode (was previously blocked)');
          try {
            window.game = new Phaser.Game(config);
            console.log('Phaser game created successfully for Taptile mode');
          } catch (error) {
            console.error('Error creating game for Taptile mode:', error);
          }
        } else if (window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
          // Game exists, restart with new mode
          console.log('Restarting existing game for Taptile mode');
          window.game.scene.stop('GameScene');
          window.game.scene.remove('GameScene');
          window.game.scene.add('GameScene', GameScene, true);
        }
      };
      
      // After creating the GameModeManager and before creating the game, update the UI to reflect the restored mode
      window.gameModeManager.updateUI();
      
      try {
        window.game = new Phaser.Game(config);
        console.log('Phaser game created successfully');
        
        // Mode switching functionality
        const modeButtons = document.querySelectorAll('.mode-btn');
        modeButtons.forEach(btn => {
          btn.addEventListener('click', async () => {
            const mode = btn.getAttribute('data-mode');
            console.log('Switching to mode:', mode);
            
            // Check if switching to Daily Challenge and player has already attempted today
            if (mode === 'daily') {
              console.log('Checking Daily Challenge attempt...');
              console.log('Global leaderboard available:', !!window.globalLeaderboard);
              
              const playerIdentifier = window.globalLeaderboard ? window.globalLeaderboard.getPlayerIdentifier() : null;
              console.log('Player identifier:', playerIdentifier);
              
              if (playerIdentifier && window.globalLeaderboard) {
                console.log('Checking daily attempt for player:', playerIdentifier);
                const attemptCheck = await window.globalLeaderboard.hasDailyAttemptToday(playerIdentifier);
                console.log('Daily attempt check result:', attemptCheck);
                
                if (attemptCheck.success && attemptCheck.hasAttempted) {
                  console.log('Player has already attempted today, showing modal');
                  // Player has already attempted today, show modal
                  const todaysScore = await window.globalLeaderboard.getTodaysDailyScore(playerIdentifier);
                  window.globalLeaderboard.showDailyAlreadyAttemptedModal(todaysScore.success ? todaysScore.data : null);
                  return; // Don't switch modes
                } else {
                  console.log('Player has not attempted today or check failed, allowing play');
                }
              } else {
                console.log('No player identifier or leaderboard not available, allowing play');
              }
            }
            
            window.gameModeManager.setMode(mode);
            // Remove restart button if switching to Daily Challenge mode
            if (mode === 'daily') {
              const restartBtn = document.getElementById('modal-restart-btn');
              if (restartBtn) restartBtn.parentNode.removeChild(restartBtn);
            }
            // Force UI update after a small delay to ensure DOM is ready
            setTimeout(() => {
              window.gameModeManager.updateUI();
            }, 100);
            // Restart game with new mode and reset all state
            if (window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
              // Full reset: destroy and recreate the scene to clear all state
              window.game.scene.stop('GameScene');
              window.game.scene.remove('GameScene');
              window.game.scene.add('GameScene', GameScene, true);
            }
          });
        });

        // Prevent page refresh for Daily Challenge mode
        window.addEventListener('beforeunload', (e) => {
          if (window.gameModeManager && !window.gameModeManager.getCurrentMode().speedIncrease) {
            // Daily Challenge mode - warn user about losing progress
            e.preventDefault();
            e.returnValue = 'You are playing Daily Challenge mode. Refreshing will lose your progress. Are you sure?';
            return e.returnValue;
          }
        });
        
        // Leaderboard functionality
        const leaderboardBtn = document.getElementById('leaderboard-btn');
        
        if (leaderboardBtn) {
          leaderboardBtn.addEventListener('click', () => {
            if (window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
              const scene = window.game.scene.keys['GameScene'];
              if (scene.leaderboardManager) {
                // Show current mode's leaderboard using the new modal style
                const currentMode = window.gameModeManager.getCurrentMode();
                const gameMode = currentMode.speedIncrease ? 'fallphabet_taptile' : 'daily_challenge';
                
                if (gameMode === 'daily_challenge') {
                  // Use the dedicated daily leaderboard modal
                  scene.leaderboardManager.showDailyLeaderboardView();
                } else {
                  // Use the new modal style for Taptile leaderboard
                  scene.leaderboardManager.showTaptileLeaderboardView();
                }
              }
            }
          });
        }
        
        // Help button functionality
        const helpBtn = document.getElementById('help-btn');
        if (helpBtn) {
          helpBtn.onclick = () => {
            const modal = document.getElementById('instructions-modal');
            modal.style.display = 'flex';
            setTimeout(() => { modal.classList.add('show'); }, 10);
          };
        }
        
        // Instructions modal close button
        const instructionsCloseBtn = document.getElementById('instructions-close-btn');
        if (instructionsCloseBtn) {
          instructionsCloseBtn.onclick = () => {
            const modal = document.getElementById('instructions-modal');
            modal.style.display = 'none';
            modal.classList.remove('show');
          };
        }
        
        // Restart button functionality
        const restartBtn = document.getElementById('modal-restart-btn');
        if (restartBtn) {
          // Remove restart button if in Daily Challenge mode
          if (window.gameModeManager && !window.gameModeManager.getCurrentMode().speedIncrease) {
            restartBtn.parentNode.removeChild(restartBtn);
          } else {
            restartBtn.onclick = () => {
              const currentMode = window.gameModeManager.getCurrentMode();
              // Allow restart for taptile mode always (Daily Challenge is one attempt per day)
              if (currentMode.speedIncrease) {
                console.log('Restarting Taptile game...');
                
                // Hide modal immediately
                const modal = document.getElementById('gameover-modal');
                modal.classList.remove('show');
                modal.style.display = 'none';
                
                // Clear any existing high score modals
                const highScoreModal = document.querySelector('.high-score-modal');
                if (highScoreModal && highScoreModal.parentNode) {
                  highScoreModal.parentNode.removeChild(highScoreModal);
                }
                
                // Clear any confetti
                const confettiContainer = document.getElementById('confetti-container');
                if (confettiContainer && confettiContainer.parentNode) {
                  confettiContainer.parentNode.removeChild(confettiContainer);
                }
                
                // Reset game state and restart scene
                if (window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
                  const scene = window.game.scene.keys['GameScene'];
                  
                  // Reset game state
                  scene.gameOver = false;
                  scene.wordsUsed = 0;
                  scene.topWord = '';
                  scene.topWordScore = 0;
                  scene.scoredWords = [];
                  scene.gameStartTime = Date.now();
                  
                  // Reset managers
                  if (scene.scoreManager) scene.scoreManager.reset();
                  if (scene.chainTracker) scene.chainTracker.resetChain();
                  if (scene.taptileSpeedManager) scene.taptileSpeedManager.start();
                  
                  // Clear any existing tiles
                  if (scene.tileSpawner) {
                    scene.tileSpawner.clearAllTiles();
                  }
                  
                  // Clear input buffer
                  if (scene.inputHandler) {
                    scene.inputHandler.clearBuffer();
                  }
                  
                  // Restart the scene
                  window.game.scene.restart('GameScene');
                  
                  console.log('Taptile game restarted successfully');
                } else {
                  console.error('Game scene not available for restart');
                }
              }
            };
          }
        }

        // --- Enhanced Share button with Instagram Story support ---
        const shareBtn = document.getElementById('modal-share-btn');
        if (shareBtn) {
          shareBtn.onclick = async () => {
            // Check if user is on Instagram
            const isInstagram = /Instagram/.test(navigator.userAgent) || 
                               window.location.hostname.includes('instagram.com') ||
                               document.referrer.includes('instagram.com');
            
            if (isInstagram) {
              // Generate and download Instagram Story image
              let wordsUsed = '';
              let highestChain = '';
              let topWord = '';
              let topWordScore = '';
              if (window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
                const scene = window.game.scene.keys['GameScene'];
                wordsUsed = scene.wordsUsed || '';
                highestChain = scene.chainTracker && scene.chainTracker.getHighestChain ? 'x' + scene.chainTracker.getHighestChain() : '';
                topWord = scene.topWord || '';
                topWordScore = scene.topWordScore || '';
              }
              // Create canvas
              const bg = new Image();
              bg.src = 'fallphabet-og.png';
              await new Promise(res => { bg.onload = res; });
              const canvas = document.createElement('canvas');
              canvas.width = 1080;
              canvas.height = 1920;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
              ctx.font = 'bold 90px Montserrat, Arial, sans-serif';
              ctx.fillStyle = '#7c3aed';
              ctx.textAlign = 'center';
              ctx.fillText('FALLPHABET', canvas.width/2, 350);
              ctx.font = '48px Arial, Helvetica, sans-serif';
              ctx.fillStyle = '#222';
              ctx.fillText(`It took me ${wordsUsed} words`, canvas.width/2, 600);
              ctx.fillText(`Top word: ${topWord} (${topWordScore} pts)`, canvas.width/2, 700);
              ctx.fillText(`Top chain: ${highestChain}`, canvas.width/2, 800);
              ctx.font = '40px Arial, Helvetica, sans-serif';
              ctx.fillStyle = '#7c3aed';
              ctx.fillText('fallphabet.com', canvas.width/2, 1800);
              // Download image
              const url = canvas.toDataURL('image/png');
              const a = document.createElement('a');
              a.href = url;
              a.download = 'fallphabet-story.png';
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              alert('Image downloaded! Open Instagram, swipe up to add a story, and select the image from your camera roll.');
              return;
            }
            
            // Regular sharing logic
            let wordsUsed = '';
            let highestChain = '';
            // Try to get from GameScene if available
            if (window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
              const scene = window.game.scene.keys['GameScene'];
              wordsUsed = scene.wordsUsed || '';
              highestChain = scene.chainTracker && scene.chainTracker.getHighestChain ? 'x' + scene.chainTracker.getHighestChain() : '';
            }
            // Fallback to DOM if needed
            if (!wordsUsed) {
              const modal = document.getElementById('gameover-modal');
              wordsUsed = modal.querySelector('#modal-words-used')?.textContent || '';
            }
            if (!highestChain) {
              const modal = document.getElementById('gameover-modal');
              highestChain = modal.querySelector('#modal-highest-chain')?.textContent || '';
            }
            // Try Web Share API first
            if (navigator.share) {
              const shareText = `It took me ${wordsUsed} words with a top chain of ${highestChain} to beat the Fallphabet today! Think you can beat me?`;
              navigator.share({
                title: 'Fallphabet',
                text: shareText,
                url: 'https://fallphabet.com'
              });
            } else {
              // Fallback: open iMessage/SMS if on iOS, else copy to clipboard
              const shareText = `It took me ${wordsUsed} words with a top chain of ${highestChain} to beat the Fallphabet today! Think you can beat me? https://fallphabet.com`;
              const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
              if (isiOS) {
                window.location.href = `sms:&body=${encodeURIComponent(shareText)}`;
              } else {
                navigator.clipboard.writeText(shareText);
                alert('Share text copied to clipboard!');
              }
            }
          };
        }

        // Modal close button logic
        const closeBtn = document.getElementById('modal-close-btn');
        if (closeBtn) {
          closeBtn.onclick = () => {
            const modal = document.getElementById('gameover-modal');
            modal.classList.remove('show');
            // Also hide the modal completely
            setTimeout(() => {
              modal.style.display = 'none';
            }, 300);
          };
        }

        // Top menu modal logic
        const howtoBtn = document.getElementById('howto-btn');
        const statsBtn = document.getElementById('stats-btn');
        const howtoModal = document.getElementById('howto-modal');
        const statsModal = document.getElementById('stats-modal');
        const howtoClose = document.getElementById('howto-close');
        const statsClose = document.getElementById('stats-close');
        howtoBtn.onclick = () => { howtoModal.classList.add('show'); };
        statsBtn.onclick = () => { statsModal.classList.add('show'); renderStatsHistory(); };
        howtoClose.onclick = () => { howtoModal.classList.remove('show'); };
        statsClose.onclick = () => { statsModal.classList.remove('show'); };
        // Dismiss modals by clicking outside or swiping down
        [howtoModal, statsModal].forEach(modal => {
          modal.addEventListener('click', e => { if (e.target === modal) modal.classList.remove('show'); });
          // Optional: add swipe down to close for mobile
        });
      } catch (error) {
        console.error('Error creating Phaser game:', error);
      }
    });

    // --- Clean, robust chain logic for unlimited chaining ---
    // Patch ChainTracker.resetChain to always set chainLevel = 1 and update UI
    ChainTracker.prototype.resetChain = function() {
      this.chainLevel = 1;
      this.clearChainWindow();
      if (window && window.game && window.game.scene && window.game.scene.keys && window.game.scene.keys['GameScene']) {
        const scene = window.game.scene.keys['GameScene'];
        if (scene.updateUI) scene.updateUI();
      }
    };
    // Patch ChainTracker.startChainWindow to always reset flag and start timer
    ChainTracker.prototype.startChainWindow = function() {
      this.clearChainWindow();
      this.chainWindowActive = true;
      this.shouldIncrementChain = false;
      this.chainWindowTimeout = setTimeout(() => {
        this.resetChain();
        this.chainWindowActive = false;
        this.shouldIncrementChain = false;
      }, this.chainWindowDuration);
    };
    // Patch ChainTracker.clearChainWindow to always clear timer and active state
    ChainTracker.prototype.clearChainWindow = function() {
      if (this.chainWindowTimeout) {
        clearTimeout(this.chainWindowTimeout);
        this.chainWindowTimeout = null;
      }
      this.chainWindowActive = false;
    };
    // Patch InputHandler.onTileTap to set flag and clear timer on first tile of new word
    const origOnTileTapFinal = InputHandler.prototype.onTileTap;
    InputHandler.prototype.onTileTap = function(pointer, tile) {
      if (!tile || !tile.isScrabbleTile) return origOnTileTapFinal.call(this, pointer, tile);
      if (this.selectedTiles.length === 0 && this.scene.chainTracker && this.scene.chainTracker.chainWindowActive) {
        this.scene.chainTracker.shouldIncrementChain = true;
        this.scene.chainTracker.clearChainWindow();
      }
      return origOnTileTapFinal.call(this, pointer, tile);
    };
    // Patch GameScene.handleWordSubmission to increment chain if flag is set, always clear flag, always start new window
    const origHandleWordSubmissionFinal = GameScene.prototype.handleWordSubmission;
    GameScene.prototype.handleWordSubmission = async function(data) {
      if (this.gameOver) return;
      await origHandleWordSubmissionFinal.call(this, data);
      if (this.chainTracker.shouldIncrementChain) {
        this.chainTracker.chainLevel++;
        if (this.chainTracker.chainLevel > this.chainTracker.highestChain) this.chainTracker.highestChain = this.chainTracker.chainLevel;
        this.chainTracker.shouldIncrementChain = false;
      }
      this.chainTracker.startChainWindow();
    };

    // Find the container width dynamically for gridWidth
    const getPlayfieldWidth = () => {
      const container = document.getElementById('playfield-container');
      if (!container) return 480;
      const style = window.getComputedStyle(container);
      const padding = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
      return container.clientWidth - padding;
    };

    // In the Phaser game config or GameScene, use getPlayfieldWidth() for gridWidth
    // Example (pseudo):
    // const gridWidth = getPlayfieldWidth();
    // ... pass gridWidth to TileSpawner and grid drawing logic ...

    function renderStatsHistory() {
      const currentMode = window.gameModeManager ? window.gameModeManager.getCurrentMode() : { speedIncrease: false };
      const statsDiv = document.getElementById('stats-history-content');
      if (currentMode.speedIncrease) {
        // Taptile mode - show continuous run stats
        renderTaptileStats(statsDiv);
      } else {
        // Daily challenge mode - show daily challenge stats
        renderDailyStats(statsDiv);
      }
    }
    
    function renderTaptileStats(statsDiv) {
      const taptileHistory = JSON.parse(localStorage.getItem('fallphabet_taptile_history') || '[]');
      
      if (!taptileHistory.length) {
        statsDiv.innerHTML = '<p>No Taptile games played yet.</p>';
        return;
      }
      
      // Calculate best stats for Taptile mode
      const bestScore = Math.max(...taptileHistory.map(h => h.score || 0));
      const bestTime = Math.max(...taptileHistory.map(h => h.timeSurvived || 0));
      const bestSpeed = Math.max(...taptileHistory.map(h => h.maxSpeed || 0));
      const totalGames = taptileHistory.length;
      
      // Find the best game
      const bestGame = taptileHistory.reduce((best, current) => 
        (current.score || 0) > (best.score || 0) ? current : best
      );
      
      statsDiv.innerHTML = `
        <div style='margin-bottom:18px;'>
          <h3 style='color:#7c3aed;margin:0 0 12px 0;'>Personal Best</h3>
          <div style='background:#fff9ef;padding:12px;border-radius:8px;border:1px solid #e5c9a8;'>
            <strong>Best Score:</strong> <span style='color:#7c3aed;font-weight:bold;'>${bestScore}</span><br/>
            <strong>Longest Survival:</strong> <span style='color:#7c3aed;font-weight:bold;'>${bestTime.toFixed(1)}s</span><br/>
            <strong>Highest Speed Reached:</strong> <span style='color:#7c3aed;font-weight:bold;'>${bestSpeed.toFixed(1)}x</span><br/>
            <strong>Total Games:</strong> ${totalGames}
          </div>
        </div>
        <div style='font-size:1.05rem;margin-bottom:8px;'><strong>Recent Runs:</strong></div>
        <ul style='margin:8px 0 0 0;padding:0;list-style:none;max-height:200px;overflow-y:auto;'>
          ${taptileHistory.slice(-8).reverse().map(h => {
            const date = new Date(h.timestamp || Date.now()).toLocaleDateString();
            return `<li style='margin-bottom:8px;padding:8px;background:#f8f9fa;border-radius:6px;'>
              <span style='color:#7c3aed;font-weight:bold;'>${date}</span><br/>
              Score: <strong>${h.score || 0}</strong> | Time: ${h.timeSurvived ? h.timeSurvived.toFixed(1) + 's' : '-'} | Speed: ${h.maxSpeed ? h.maxSpeed.toFixed(1) + 'x' : '-'} | Words: ${h.wordsUsed || 0}
            </li>`;
          }).join('')}
        </ul>
      `;
    }
    
    function renderDailyStats(statsDiv) {
      const history = JSON.parse(localStorage.getItem('fallphabetHistory') || '[]');
      
      if (!history.length) {
        statsDiv.innerHTML = '<p>No daily challenge games played yet.</p>';
        return;
      }
      
      // Calculate best stats for Daily mode
      const fewestWords = Math.min(...history.map(h => h.wordsUsed));
      const highestScore = Math.max(...history.map(h => h.score ?? 0));
      let longestWord = '';
      history.forEach(h => {
        if (h.longestWord && h.longestWord.length > longestWord.length) longestWord = h.longestWord;
      });
      
      statsDiv.innerHTML = `
        <div style='margin-bottom:18px;'>
          <h3 style='color:#7c3aed;margin:0 0 12px 0;'>Daily Challenge Best</h3>
          <div style='background:#fff9ef;padding:12px;border-radius:8px;border:1px solid #e5c9a8;'>
            <strong>Best (fewest) words to win:</strong> ${fewestWords}<br/>
            <strong>Highest score:</strong> ${highestScore}<br/>
            <strong>Longest word ever:</strong> <span style='color:#7c3aed;font-weight:bold;'>${longestWord || '-'}</span>
          </div>
        </div>
        <div style='font-size:1.05rem;margin-bottom:8px;'><strong>Recent Games:</strong></div>
        <ul style='margin:8px 0 0 0;padding:0;list-style:none;max-height:180px;overflow-y:auto;'>
          ${history.slice(-10).reverse().map(h =>
            `<li style='margin-bottom:8px;'><span style='color:#7c3aed;font-weight:bold;'>${h.date}</span>: ${h.wordsUsed} words, Top: ${h.topWord || '-'} (${h.topWordScore || 0} pts), Longest: ${h.longestWord || '-'}, Score: ${h.score ?? 0}</li>`
          ).join('')}
        </ul>
      `;
    }

    function saveGameToHistory(stats) {
      const history = JSON.parse(localStorage.getItem('fallphabetHistory') || '[]');
      history.push(stats);
      localStorage.setItem('fallphabetHistory', JSON.stringify(history));
    }
    
    function saveTaptileGameHistory(stats) {
      const history = JSON.parse(localStorage.getItem('fallphabet_taptile_history') || '[]');
      history.push(stats);
      // Keep only the last 50 games to prevent localStorage from getting too large
      if (history.length > 50) {
        history.splice(0, history.length - 50);
      }
      localStorage.setItem('fallphabet_taptile_history', JSON.stringify(history));
    }
  </script>
</body>
</html>
